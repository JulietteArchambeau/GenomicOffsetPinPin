---
title: "Spatial predictions of the current genetic composition"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 5,fig.height = 4,cache=TRUE,cache.lazy = FALSE)
options(width = 300)
library(knitr)
library(hierfstat)
library(reshape2)
library(ggbiplot)
library(gdm)
#library(cowplot)
#library(ggplot2)
#library(ggpubr)
#library(stringi)
library(beepr)
library(dplyr)
#library(devtools)
#library(xtable)
library(tidyverse)
#library(tibble)
library(gradientForest)
library(raster)
library(sgdm)
library(adespatial) # to calculate the Moran eigen vectors
```


<!-- cache.lazy = FALSE is because one of the GF models had a error message and stopped the compilation of the rmarkdown document. -->
<!-- Here the solution: https://stackoverflow.com/questions/39417003/long-vectors-not-supported-yet-error-in-rmd-but-not-in-r-script -->


<!-- Functions & Options used -->

```{r FuntionsOptionsUsed,echo=F}
source("../../scripts/Functions/corpmat.R")
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

# Gray scale
grayscale_colors <- gray.colors(100,            # number of different color levels
                                start = 0.0,    # how black (0) to go
                                end = 1.0,      # how white (1) to go
                                gamma = 2.2,    # correction between how a digital
                                # camera sees the world and how human eyes see it
                                alpha = NULL)

PlotCors <- function(data,select.var){
  cor <- cor(data[,select.var])

# matrix of the p-value of the correlation
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=45, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", 
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- prcomp(data[,select.var], center = TRUE,scale. = TRUE)

ggbiplot(pca,varname.size =4) +  ylim(-2.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
}
```

# Variable selection


The variables were extracted from the EuMedClim database.

Criteria to include the variables:

- Variables included in Worldclim, to facilitate the projection under future climates.

- less than 0.80 correlated.



```{r LoadEnvData}
data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
data <- data %>% select(prov,contains("ude_prov"),contains("bio"),contains("top_prov"),"depth_roots_prov")
colnames(data) <- c("prov",str_sub(colnames(data)[-1],1,-6))
data <- unique(data)
data <- data[!(data$prov=="ROD"),]
data

topo <- readRDS(file="../../data/Topography/DfTopoVarbyProv.rds")
topo <- topo %>% dplyr::select(prov,TRI_WGS84_90m_R) %>% 
                 dplyr::rename(TRI=TRI_WGS84_90m_R)
data <- merge(data,topo,by="prov")
data
```

```{r VizualizeEnvData,fig.height=13,fig.width=13}
cor <- data %>%  select(-prov) %>% cor()
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=23, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", number.cex =0.8,tl.cex = 0.8,
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- data %>%   select(-prov) %>%  prcomp(center = TRUE,scale. = TRUE)
ggbiplot(pca,varname.size =4) +  ylim(-4.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
```


## Set AvgSand

Topographic variable: `TRI`.

Soil variables:

  - `sand_top` = sand content in the top layers of the soil
  - `depth_roots` = Depth available to roots

Climatic variables representing episodic events:

  - `bio1`: annual daily mean temperature (°C)
  - `bio2`: mean diurnal temperature range (max-min, °C)
  - `bio12`: annual precipitation (mm)
  - `bio14`: precipitation of the driest month (mm)


```{r SelectEnvDataSetAvgSand,fig.height=6,fig.width=6}
select.var.AvgSand <- c("bio1","bio2","bio12","bio14","sand_top","depth_roots","TRI")
PlotCors(data,select.var = select.var.AvgSand)
```


## Set AvgWater

Topographic variable: `TRI`.

Soil variables:

  - `water_top` = Total available water content
  - `depth_roots` = Depth available to roots

Climatic variables representing episodic events:

  - `bio1`: annual daily mean temperature (°C)
  - `bio2`: mean diurnal temperature range (max-min, °C)
  - `bio12`: annual precipitation (mm)
  - `bio14`: precipitation of the driest month (mm)


```{r SelectEnvDataSetAvgWater,fig.height=6,fig.width=6}
select.var.AvgWater <- c("bio1","bio2","bio12","bio14","water_top","depth_roots","TRI")
PlotCors(data,select.var = select.var.AvgWater)
```

## Set ExtSand

Topographic variable: `TRI`.

Soil variables:

  - `sand_top` = sand content in the top layers of the soil
  - `depth_roots` = Depth available to roots

Climatic variables representing episodic events:

  - `bio5`: max temperature of the warmest month (°C)
  - `bio6`: min temperature of the coldest month (°C)
  - `bio13`: precipitation of the wettest month (mm)
  - `bio14`: precipitation of the driest month (mm)
  
  
```{r SelectEnvDataSetExtSand,fig.height=6,fig.width=6}
select.var.ExtSand <- c("bio13","bio14","bio5","bio6","sand_top","depth_roots","TRI")
PlotCors(data,select.var = select.var.ExtSand)
```


## Set ExtWater

Topographic variable: `TRI`.

Soil variables:

  - `water_top` = sand content in the top layers of the soil
  - `depth_roots` = Depth available to roots

Climatic variables representing episodic events:

  - `bio5`: max temperature of the warmest month (°C)
  - `bio6`: min temperature of the coldest month (°C)
  - `bio13`: precipitation of the wettest month (mm)
  - `bio14`: precipitation of the driest month (mm)
  
  
```{r SelectEnvDataSetExtWater,fig.height=6,fig.width=6}
select.var.ExtWater <- c("bio13","bio14","bio5","bio6","water_top","depth_roots","TRI")
PlotCors(data,select.var = select.var.ExtWater)
```


# Fitting the models

## GDM analysis


```{r}
perf <- data.frame(Set=c("AvgSand","AvgWater","ExtSand","ExtWater"),ExpDev=NA,CV9=NA,CV6=NA,CV2=NA)
```


> Load the Fst matrix

```{r LoadFstMatrix}
fstmat <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsBS.rds")
fstmat <- as.data.frame(fstmat) 
fstmat <- fstmat %>%  tibble::rownames_to_column("prov") # The distance matrix must have as the first column the names of the provenances
mean(unlist(fstmat[,-1]),na.rm=T)
range(unlist(fstmat[,-1]),na.rm=T)
sd(unlist(fstmat[,-1]),na.rm=T)
```

### Set AvgSand

```{r FormatDataGDMAvgSand}
subdata <- data[,c("prov","latitude","longitude",select.var.AvgSand)]

gdmTab <- formatsitepair(fstmat, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab)
```

Fit the GDM model:

```{r RunningGDMAvgSand}
# Running the GDM model:
gdm.AvgSand <- gdm(gdmTab, geo=T)
gdm.AvgSand
```

Let's evaluate the explanatory and predictive performance of the model:

```{r PerfGDMAvgSand}
# Deviance explained 
perf[perf$Set=="AvgSand","ExpDev"] <- gdm.AvgSand$explained

# sum(gdm.AvgSand$coefficients) # https://rdrr.io/cran/gdm/src/R/GDM_Table_Funcs.R
# if sum = 0: The algorithm was unable to fit a model to your data. The sum of the spline coefficients = 0 and deviance explained = NULL. Returning NULL object.

# Cross-validation
perf[perf$Set=="AvgSand","CV9"] <- sgdm::gdm.cv(gdmTab,nfolds = 9,performance = "r2",geo=T)
perf[perf$Set=="AvgSand","CV2"] <- sgdm::gdm.cv(gdmTab,nfolds = 2,performance = "r2",geo=T)
perf[perf$Set=="AvgSand","CV6"] <- sgdm::gdm.cv(gdmTab,nfolds = 6,performance = "r2",geo=T)

perf 
```

Fitting the I-splines:

```{r IsplinesGDMAvgSand,fig.height=7,fig.width=7,message=F}
# I-splines
par(mfrow=c(2,2))
gdm.AvgSand.splineDat <- isplineExtract(gdm.AvgSand)

plot(gdm.AvgSand.splineDat$x[,"Geographic"], gdm.AvgSand.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial genetic distance") # or ylab= f(Geographic distance)

gdm.AvgSand.pred <- predict.gdm(gdm.AvgSand, gdmTab)

plot(gdmTab$distance, gdm.AvgSand.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.AvgSand.splineDat[[1]][,"bio1"], 
     gdm.AvgSand.splineDat[[2]][,"bio1"], 
     type="l",
     lwd=3, 
     xlab="Annual daily mean T° (C°)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgSand.splineDat[[1]][,"bio14"], 
     gdm.AvgSand.splineDat[[2]][,"bio14"], 
     type="l",
     lwd=3, 
     xlab="Precipitation of the driest month (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgSand.splineDat[[1]][,"bio2"], 
     gdm.AvgSand.splineDat[[2]][,"bio2"], 
     type="l",
     lwd=3, 
     xlab="Mean diurnal T° range (max-min, °C)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgSand.splineDat[[1]][,"bio12"], 
     gdm.AvgSand.splineDat[[2]][,"bio12"], 
     type="l",
     lwd=3, 
     xlab="Annual precipitation (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgSand.splineDat[[1]][,"sand_top"], 
     gdm.AvgSand.splineDat[[2]][,"sand_top"], 
     type="l",
     lwd=3, 
     xlab="Sand content in top layers (%)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgSand.splineDat[[1]][,"depth_roots"], 
     gdm.AvgSand.splineDat[[2]][,"depth_roots"], 
     type="l",
     lwd=3, 
     xlab="Depth available to roots (cm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgSand.splineDat[[1]][,"TRI"], 
     gdm.AvgSand.splineDat[[2]][,"TRI"], 
     type="l",
     lwd=3, 
     xlab="Topographic Ruggdness Index", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))
```


### Set AvgWater

```{r FormatDataGDMAvgWater}
subdata <- data[,c("prov","latitude","longitude",select.var.AvgWater)]

gdmTab <- formatsitepair(fstmat, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab)
```

Fit the GDM model:

```{r RunningGDMAvgWater}
# Running the GDM model:
gdm.AvgWater <- gdm(gdmTab, geo=T)
gdm.AvgWater
```

Let's evaluate the explanatory and predictive performance of the model:

```{r PerfGDMAvgWater,message=F}
# Deviance explained 
perf[perf$Set=="AvgWater","ExpDev"] <- gdm.AvgWater$explained

# Cross-validation
perf[perf$Set=="AvgWater","CV9"] <- sgdm::gdm.cv(gdmTab,nfolds = 9,performance = "r2",geo=T)
perf[perf$Set=="AvgWater","CV2"] <- sgdm::gdm.cv(gdmTab,nfolds = 2,performance = "r2",geo=T)
perf[perf$Set=="AvgWater","CV6"] <- sgdm::gdm.cv(gdmTab,nfolds = 6,performance = "r2",geo=T)
perf
```

Fitting the I-splines:

```{r IsplinesGDMAvgWater,fig.height=7,fig.width=7,message=F}
# I-splines
par(mfrow=c(2,2))
gdm.AvgWater.splineDat <- isplineExtract(gdm.AvgWater)

plot(gdm.AvgWater.splineDat$x[,"Geographic"], gdm.AvgWater.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial genetic distance") # or ylab= f(Geographic distance)

gdm.AvgWater.pred <- predict.gdm(gdm.AvgWater, gdmTab)

plot(gdmTab$distance, gdm.AvgWater.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.AvgWater.splineDat[[1]][,"bio1"], 
     gdm.AvgWater.splineDat[[2]][,"bio1"], 
     type="l",
     lwd=3, 
     xlab="Annual daily mean T° (C°)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgWater.splineDat[[1]][,"bio14"], 
     gdm.AvgWater.splineDat[[2]][,"bio14"], 
     type="l",
     lwd=3, 
     xlab="Precipitation of the driest month (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgWater.splineDat[[1]][,"bio2"], 
     gdm.AvgWater.splineDat[[2]][,"bio2"], 
     type="l",
     lwd=3, 
     xlab="Mean diurnal T° range (max-min, °C)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgWater.splineDat[[1]][,"bio12"], 
     gdm.AvgWater.splineDat[[2]][,"bio12"], 
     type="l",
     lwd=3, 
     xlab="Annual precipitation (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgWater.splineDat[[1]][,"water_top"], 
     gdm.AvgWater.splineDat[[2]][,"water_top"], 
     type="l",
     lwd=3, 
     xlab="Water content in top layers (%)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgWater.splineDat[[1]][,"depth_roots"], 
     gdm.AvgWater.splineDat[[2]][,"depth_roots"], 
     type="l",
     lwd=3, 
     xlab="Depth available to roots (cm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.AvgWater.splineDat[[1]][,"TRI"], 
     gdm.AvgWater.splineDat[[2]][,"TRI"], 
     type="l",
     lwd=3, 
     xlab="Topographic Ruggdness Index", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))
```


### Set ExtSand

```{r FormatDataGDMExtSand}
subdata <- data[,c("prov","latitude","longitude",select.var.ExtSand)]

gdmTab <- formatsitepair(fstmat, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab)
```


Fit the GDM model:

```{r RunningGDMExtSand}
# Running the GDM model:
gdm.ExtSand <- gdm(gdmTab, geo=T)
gdm.ExtSand
```

Let's evaluate the explanatory and predictive performance of the model:

```{r PerfGDMExtSand,message=F}
# Deviance explained 
perf[perf$Set=="ExtSand","ExpDev"] <- gdm.ExtSand$explained

# Cross-validation
perf[perf$Set=="ExtSand","CV9"] <- sgdm::gdm.cv(gdmTab,nfolds = 9,performance = "r2",geo=T)
perf[perf$Set=="ExtSand","CV2"] <- sgdm::gdm.cv(gdmTab,nfolds = 2,performance = "r2",geo=T)
perf[perf$Set=="ExtSand","CV6"] <- sgdm::gdm.cv(gdmTab,nfolds = 6,performance = "r2",geo=T)
perf
```

Fitting the I-splines:

```{r IsplinesGDMExtSand,fig.height=7,fig.width=7,message=F}
# I-splines
par(mfrow=c(2,2))
gdm.ExtSand.splineDat <- isplineExtract(gdm.ExtSand)

plot(gdm.ExtSand.splineDat$x[,"Geographic"], gdm.ExtSand.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial genetic distance") # or ylab= f(Geographic distance)

gdm.ExtSand.pred <- predict.gdm(gdm.ExtSand, gdmTab)

plot(gdmTab$distance, gdm.ExtSand.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.ExtSand.splineDat[[1]][,"bio5"], 
     gdm.ExtSand.splineDat[[2]][,"bio5"], 
     type="l",
     lwd=3, 
     xlab="Max T° warmest month (°C)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtSand.splineDat[[1]][,"bio6"], 
     gdm.ExtSand.splineDat[[2]][,"bio6"], 
     type="l",
     lwd=3, 
     xlab="Min T° of the coldest month (°C)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtSand.splineDat[[1]][,"bio13"], 
     gdm.ExtSand.splineDat[[2]][,"bio13"], 
     type="l",
     lwd=3, 
     xlab="Precipitation of the wettest month (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtSand.splineDat[[1]][,"bio14"], 
     gdm.ExtSand.splineDat[[2]][,"bio14"], 
     type="l",
     lwd=3, 
     xlab="Precipitation of the driest month (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtSand.splineDat[[1]][,"sand_top"], 
     gdm.ExtSand.splineDat[[2]][,"sand_top"], 
     type="l",
     lwd=3, 
     xlab="Sand content in top layers (%)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtSand.splineDat[[1]][,"depth_roots"], 
     gdm.ExtSand.splineDat[[2]][,"depth_roots"], 
     type="l",
     lwd=3, 
     xlab="Depth available to roots (cm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtSand.splineDat[[1]][,"TRI"], 
     gdm.ExtSand.splineDat[[2]][,"TRI"], 
     type="l",
     lwd=3, 
     xlab="Topographic Ruggdness Index", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))
```



### Set ExtWater

```{r FormatDataGDMExtWater}
subdata <- data[,c("prov","latitude","longitude",select.var.ExtWater)]

gdmTab <- formatsitepair(fstmat, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab)
```

Fit the GDM model:

```{r RunningGDMExtWater}
# Running the GDM model:
gdm.ExtWater <- gdm(gdmTab, geo=T)
gdm.ExtWater
```

Let's evaluate the explanatory and predictive performance of the model:

```{r PerfGDMExtWater,message=F}
# Deviance explained 
perf[perf$Set=="ExtWater","ExpDev"] <- gdm.ExtWater$explained

# Cross-validation
perf[perf$Set=="ExtWater","CV9"] <- sgdm::gdm.cv(gdmTab,nfolds = 9,performance = "r2",geo=T)
perf[perf$Set=="ExtWater","CV2"] <- sgdm::gdm.cv(gdmTab,nfolds = 2,performance = "r2",geo=T)
perf[perf$Set=="ExtWater","CV6"] <- sgdm::gdm.cv(gdmTab,nfolds = 6,performance = "r2",geo=T)
perf
```

Fitting the I-splines:

```{r IsplinesGDMExtWater,fig.height=7,fig.width=7,message=F}
# I-splines
par(mfrow=c(2,2))
gdm.ExtWater.splineDat <- isplineExtract(gdm.ExtWater)

plot(gdm.ExtWater.splineDat$x[,"Geographic"], gdm.ExtWater.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial genetic distance") # or ylab= f(Geographic distance)

gdm.ExtWater.pred <- predict.gdm(gdm.ExtWater, gdmTab)

plot(gdmTab$distance, gdm.ExtWater.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.ExtWater.splineDat[[1]][,"bio5"], 
     gdm.ExtWater.splineDat[[2]][,"bio5"], 
     type="l",
     lwd=3, 
     xlab="Max T° warmest month (°C)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtWater.splineDat[[1]][,"bio6"], 
     gdm.ExtWater.splineDat[[2]][,"bio6"], 
     type="l",
     lwd=3, 
     xlab="Min T° of the coldest month (°C)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtWater.splineDat[[1]][,"bio13"], 
     gdm.ExtWater.splineDat[[2]][,"bio13"], 
     type="l",
     lwd=3, 
     xlab="Precipitation of the wettest month (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtWater.splineDat[[1]][,"bio14"], 
     gdm.ExtWater.splineDat[[2]][,"bio14"], 
     type="l",
     lwd=3, 
     xlab="Precipitation of the driest month (mm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtWater.splineDat[[1]][,"water_top"], 
     gdm.ExtWater.splineDat[[2]][,"water_top"], 
     type="l",
     lwd=3, 
     xlab="Water content in top layers (%)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtWater.splineDat[[1]][,"depth_roots"], 
     gdm.ExtWater.splineDat[[2]][,"depth_roots"], 
     type="l",
     lwd=3, 
     xlab="Depth available to roots (cm)", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))

plot(gdm.ExtWater.splineDat[[1]][,"TRI"], 
     gdm.ExtWater.splineDat[[2]][,"TRI"], 
     type="l",
     lwd=3, 
     xlab="Topographic Ruggdness Index", 
     ylab="Partial genetic distance",
     ylim=c(0,0.2))
```



## GF analysis

> Calculate the Moran's eigenvectors

```{r MoranEigenVectors}
mem <- data %>% select(latitude,longitude) %>% dbmem

# Merge coordinates and MEM
mem <- bind_cols(data[,c("prov","latitude","longitude")],mem)
mem
```


```{r LoadGenoPrepared}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequencies.rds")
```

Removing the SNPs that are polymorphic in more than 5 populations.

```{r RmMinorAlleleFrequencies}
vec <- apply(geno[,-1],2,function(x) length(unique(x)))
vecsup <- vec[vec>5]
snps <- names(vecsup)
length(vecsup) # Number of SNPs polymorphic in > 5 populations
ncol(geno[,-1]) - length(vecsup) # Number of SNPs polymorphic in less than or equal to 5 populations
genoMAF <- geno %>% dplyr::select(contains(c("prov",snps)))
```

### Set AvgSand


```{r FormatDataGFAvgSand}
subdata <- data[,c("prov","latitude","longitude",select.var.AvgSand)]

df <- dplyr::inner_join(mem,subdata,by=c("prov","latitude","longitude"))
df <- inner_join(df,genoMAF,by="prov")
kable(df[1:10,1:20])

# Dataset of geographic and env. variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables

maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# SNP dataset
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
```

Fit the GF model: 

```{r RunGFmodelAvgSand,eval=F}
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/GFAvgSand.rds")) 
```


```{r LoadModelAvgSand}
gf <- readRDS(file=paste0("../../outputs/GF/models/GFAvgSand.rds"))
```


```{r PlotOverallImptanceGFAvgSand, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
mean(gf$result)
sd(gf$result)
```

```{r PlotCumulativeImptanceGFAvgSand,fig.height=4,fig.width=4}
# Annual daily mean T° (C°)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio1",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Annual daily mean T° (C°)", font=2,cex=0.8)

# Mean diurnal T° range (max-min, °C)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio2",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Mean diurnal T° range (max-min, °C)", font=2,cex=0.8)

# Annual precipitation (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio12",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Annual precipitation (mm)", font=2,cex=0.8)

# Precipitation of the driest month (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio14",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Precipitation of the driest month (mm)", font=2,cex=0.8)

# Sand content
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="sand_top",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Sand content in the top layers (%)", font=2,cex=0.8)

# Depth available to roots
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="depth_roots",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Depth available to roots", font=2,cex=0.8)

# TRI
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="TRI",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Topographic Ruggdness Index", font=2,cex=0.8)
```




### Set AvgWater


```{r FormatDataGFAvgWater}
subdata <- data[,c("prov","latitude","longitude",select.var.AvgWater)]

df <- dplyr::inner_join(mem,subdata,by=c("prov","latitude","longitude"))
df <- inner_join(df,genoMAF,by="prov")
kable(df[1:10,1:20])

# Dataset of geographic and env. variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables

maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# SNP dataset
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
```

Fit the GF model: 

```{r RunGFmodelAvgWater,eval=F}
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/GFAvgWater.rds")) 
```


```{r LoadModelAvgWater}
gf <- readRDS(file=paste0("../../outputs/GF/models/GFAvgWater.rds"))
```


```{r PlotOverallImptanceGFAvgWater, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
mean(gf$result)
sd(gf$result)
```

```{r PlotCumulativeImptanceGFAvgWater,fig.height=4,fig.width=4}
# Annual daily mean T° (C°)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio1",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Annual daily mean T° (C°)", font=2,cex=0.8)

# Mean diurnal T° range (max-min, °C)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio2",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Mean diurnal T° range (max-min, °C)", font=2,cex=0.8)

# Annual precipitation (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio12",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Annual precipitation (mm)", font=2,cex=0.8)

# Precipitation of the driest month (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio14",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Precipitation of the driest month (mm)", font=2,cex=0.8)

# Water content
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="water_top",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Water content in the top layers (%)", font=2,cex=0.8)

# Depth available to roots
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="depth_roots",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Depth available to roots", font=2,cex=0.8)

# TRI
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="TRI",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Topographic Ruggdness Index", font=2,cex=0.8)
```



### Set ExtSand


```{r FormatDataGFExtSand}
subdata <- data[,c("prov","latitude","longitude",select.var.ExtSand)]

df <- dplyr::inner_join(mem,subdata,by=c("prov","latitude","longitude"))
df <- inner_join(df,genoMAF,by="prov")
kable(df[1:10,1:20])

# Dataset of geographic and env. variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables

maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# SNP dataset
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
```

Fit the GF model: 

```{r RunGFmodelExtSand,eval=F}
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/GFExtSand.rds")) 
```


```{r LoadModelExtSand}
gf <- readRDS(file=paste0("../../outputs/GF/models/GFExtSand.rds"))
```


```{r PlotOverallImptanceGFExtSand, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
mean(gf$result)
sd(gf$result)
```

```{r PlotCumulativeImptanceGFExtSand,fig.height=4,fig.width=4}
# Max T° warmest month (°C)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio5",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Max T° warmest month (°C)", font=2,cex=0.8)

# Min T° of the coldest month (°C)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio6",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Min T° of the coldest month (°C)", font=2,cex=0.8)

# Precipitation of the wettest month (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio13",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Precipitation of the wettest month (mm)", font=2,cex=0.8)

# Precipitation of the driest month (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio14",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Precipitation of the driest month (mm)", font=2,cex=0.8)

# Sand content
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="sand_top",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Sand content in the top layers (%)", font=2,cex=0.8)

# Depth available to roots
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="depth_roots",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Depth available to roots", font=2,cex=0.8)

# TRI
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="TRI",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Topographic Ruggdness Index", font=2,cex=0.8)
```



### Set ExtWater


```{r FormatDataGFExtWater}
subdata <- data[,c("prov","latitude","longitude",select.var.ExtWater)]

df <- dplyr::inner_join(mem,subdata,by=c("prov","latitude","longitude"))
df <- inner_join(df,genoMAF,by="prov")
kable(df[1:10,1:20])

# Dataset of geographic and env. variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables

maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# SNP dataset
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
```

Fit the GF model: 

```{r RunGFmodelExtWater,eval=F}
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/GFExtWater.rds")) 
```


```{r LoadModelExtWater}
gf <- readRDS(file=paste0("../../outputs/GF/models/GFExtWater.rds"))
```


```{r PlotOverallImptanceGFExtWater, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
mean(gf$result)
sd(gf$result)
```

```{r PlotCumulativeImptanceGFExtWater,fig.height=4,fig.width=4}
# Max T° warmest month (°C)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio5",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Max T° warmest month (°C)", font=2,cex=0.8)

# Min T° of the coldest month (°C)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio6",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Min T° of the coldest month (°C)", font=2,cex=0.8)

# Precipitation of the wettest month (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio13",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Precipitation of the wettest month (mm)", font=2,cex=0.8)

# Precipitation of the driest month (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio14",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Precipitation of the driest month (mm)", font=2,cex=0.8)

# Water content
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="water_top",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Water content in the top layers (%)", font=2,cex=0.8)

# Depth available to roots
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="depth_roots",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Depth available to roots", font=2,cex=0.8)

# TRI
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="TRI",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Topographic Ruggdness Index", font=2,cex=0.8)
```


### Test with lat/long

As I can't include in the projection the moran eigen vectors, I'm trying to include the latitude and longitude instead of the Moran eigen vectors.

```{r FormatDataGFAvgWaterGeo}
subdata <- data[,c("prov","latitude","longitude",select.var.AvgWater)]

df <- inner_join(subdata,genoMAF,by="prov")
kable(df[1:10,1:20])

# Dataset of geographic and env. variables
envGF <- df %>% dplyr::select(-contains(c("prov","SNP"))) # get climate & lat/long variables

maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# SNP dataset
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
```

Fit the GF model: 

```{r RunGFmodelAvgWaterGeo,eval=F}
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/GFAvgWaterGeo.rds")) 
```


```{r LoadModelAvgWaterGeo}
gf <- readRDS(file=paste0("../../outputs/GF/models/GFAvgWaterGeo.rds"))
```


```{r PlotOverallImptanceGFAvgWaterGeo, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
mean(gf$result)
sd(gf$result)
```

```{r PlotCumulativeImptanceGFAvgWaterGeo,fig.height=4,fig.width=4}
# Latitude
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="latitude",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Latitude", font=2,cex=0.8)

# Longitude
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="longitude",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Longitude", font=2,cex=0.8)

# Annual daily mean T° (C°)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio1",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Annual daily mean T° (C°)", font=2,cex=0.8)

# Mean diurnal T° range (max-min, °C)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio2",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Mean diurnal T° range (max-min, °C)", font=2,cex=0.8)

# Annual precipitation (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio12",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Annual precipitation (mm)", font=2,cex=0.8)

# Precipitation of the driest month (mm)
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="bio14",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Precipitation of the driest month (mm)", font=2,cex=0.8)

# Water content
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="water_top",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Water content in the top layers (%)", font=2,cex=0.8)

# Depth available to roots
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="depth_roots",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Depth available to roots", font=2,cex=0.8)

# TRI
plot(gf, plot.type="Cumulative.Importance",
     imp.vars="TRI",
     plot.args=list(show.species=FALSE,show.overall=TRUE))
mtext(side=1, line=3.5, "Topographic Ruggdness Index", font=2,cex=0.8)
```



# Projecting across the species range

Projections are done with the best set of variables (`AvgWter`): `TRI`, `water_top`, `depth_roots`, `bio1`, `bio2`, `bio12` and `bio14`.

## Load data 

### Maritime pine distribution (mask)

```{r MaritimePineDistriMask}
# Maritime pine distribution from EUFORGEN (shapefile)
PinpinDistri  <- shapefile('../../../../Pinpin_Clonapin/maps/pinus_pinaster_distribution/Pinus_pinaster_EUFORGEN.shp')
```

### Hillshade (background)

```{r MapBackground}
# fond de carte
# https://land.copernicus.eu/imagery-in-situ/eu-dem/eu-dem-v1-0-and-derived-products/slope?tab=download
# Need to create an account

# I took the hillsahede map from here:
# https://www.eea.europa.eu/data-and-maps/data/digital-elevation-model-of-europe

background <- raster("../../data/maps/EuropeanData/hillshade1x1.tif")
background <- projectRaster(background, crs="+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
e <- extent(-10, 14, 31, 50)
background <- crop(background, e)
```

### Rasters of climatic, soil and topographic variables

```{r LoadStackAvgWater}
stackall <- stack("../../data/StacksEnvVars/StackAvgWater.grd")
```


## GDM

```{r TransformingBeforeProjectionGDMCurrentClimate}
rastTrans <- gdm.transform(gdm.AvgWater, stackall) 

rastDat <- na.omit(getValues(rastTrans))
pca <- prcomp(rastDat, center=TRUE, scale.=FALSE)
```

> 1/ Following the GDM vignette

```{r ProjectionGDMCurrentClimate, fig.height=8, fig.width=8}
pcaRast <- predict(rastTrans, pca, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0) 
```

> Following sciprt from the paper of Fitzpatrick and Keller (2014)

```{r BiplotGDMCurrentClimate, fig.height=8, fig.width=8}
##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1 

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]

rasValue <- raster::extract(stackall, PinpinDistri,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)


mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(outRast, r = 1, g = 2, b = 3,add=T,bgalpha=0)

nvs <- dim(pca$rotation)[1]
vec <-  row.names(pca$rotation)
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 15
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
pca$rotation
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)
```



## GF

### Set AvgWater


```{r TransformingBeforeProjectionGFCurrentClimate}
# Load model estimating on the AvgWater set of variables
gf <- readRDS(file=paste0("../../outputs/GF/models/GFAvgWater.rds"))

rasValue <- raster::extract(stackall, PinpinDistri,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

###
# This method doesn't work: "Erreur : impossible d'allouer un vecteur de taille 391.6 Go" when trying to calculate the MEM for all values
# ex.df.coords <- cbind(xyFromCell(stackall,rasValue[,1]),rasValue)
# ex.df.coords <- ex.df.coords %>% rename(latitude=x,longitude=y)
# moraneigenvectors <- ex.df.coords %>% select(latitude,longitude) %>% dbmem
###

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)
```

```{r ProjectionGFCurrentClimate, fig.height=8, fig.width=8}
##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(outRast, r = 1, g = 2, b = 3,add=T,bgalpha=0)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

> Biplot of the genetic space

```{r BiplotGFCurrentClimate, echo=F}
nvs <- dim(pca$rotation)[1]
vec <- names(gf$X)[5:10]
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 40
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1

plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+",cex=3,col="black")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


# Show the provenances
PredsProvs <- predict(gf)
PCprovs <- predict(pca, PredsProvs)
points(PCprovs[, 1:2])

# Show the alleles
SpsWtd <- sweep(gf$Y, 2, apply(gf$Y, 2, min),  "-")
SpsWtdPCs <- (t(SpsWtd) %*% (PCprovs[, 1:2]))/colSums(SpsWtd)
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 3, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(SpsWtdPCs, pch = ".",cex=3,col="black") # col = alpha("black", 0.4)

# Show some alleles
snp <- "SNP_0008"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)

snp <- "SNP_0109"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x10")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*10)


snp <- "SNP_6088"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)
```


### Set test lat/long


```{r TransformingBeforeProjectionGFCurrentClimateLatLong}
# Load model estimating on the test lat/long set of variables
gf <- readRDS(file=paste0("../../outputs/GF/models/GFAvgWaterGeo.rds"))

rasValue <- raster::extract(stackall, PinpinDistri,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

###
rasValue <- cbind(xyFromCell(stackall,rasValue[,1]),rasValue)
rasValue <- rasValue %>% rename(longitude=x,latitude=y)
###

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-3]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)
```

```{r ProjectionGFCurrentClimateLatLong, fig.height=8, fig.width=8}
##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(outRast, r = 1, g = 2, b = 3,add=T,bgalpha=0)
```

> Biplot of the genetic space

```{r BiplotGFCurrentClimateLatLong, echo=F}
nvs <- dim(pca$rotation)[1]
vec <- names(gf$X)
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 40
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1

plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+",cex=3,col="black")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.2)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


# Show the provenances
PredsProvs <- predict(gf)
PCprovs <- predict(pca, PredsProvs)
points(PCprovs[, 1:2])

# Show the alleles
SpsWtd <- sweep(gf$Y, 2, apply(gf$Y, 2, min),  "-")
SpsWtdPCs <- (t(SpsWtd) %*% (PCprovs[, 1:2]))/colSums(SpsWtd)
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 3, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5) 
points(SpsWtdPCs, pch = ".",cex=3,col="black") # col = alpha("black", 0.4)

# Show some alleles
snp <- "SNP_0008"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)

snp <- "SNP_0109"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x10")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*10)


snp <- "SNP_6088"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)
```


`r knitr::opts_chunk$set(eval = F)`


---
title: "Formatting and exploring genomic data"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
editor_options: 
  chunk_output_type: console
---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 5,fig.height = 4,cache=F)
options(width = 300)
library(knitr)      # CRAN v1.26
library(dplyr)      # CRAN v1.0.0
library(tidyverse)  # CRAN v1.3.0
library(readxl)
library(magrittr)
library(kableExtra) # CRAN v1.1.0
```

# Load & format all genomic data

```{r LoadGenomicData, warning=F,message=F}
data <- read_excel("data/GenomicData/data_curated_Affx+Inf.xlsx", sheet = 5, col_names = FALSE)
```

```{r DupplicatedPIA3, warning=F,message=F,echo=F,eval=F}

# First genomic file sent by Santi
# --------------------------------

data <- read_excel("data/GenomicData/data_curated_Affx+Inf_PIA3double.xlsx", sheet = 3, col_names = FALSE)

# The clone PIA3 is duplicated.

PIA3 <- data %>%
  filter(...1=="PIA3") %>%
  t() %>%
  set_colnames(c("PIA3_Inf","PIA3_Affx")) %>%
  as_tibble() %>%
  slice(-c(1,2)) %>%
  filter(!PIA3_Affx=="---",!PIA3_Inf=="---") %>%
  mutate(Diff=PIA3_Inf==PIA3_Affx)

# There are 86 differences between the two copies. 

# I initially renamed differently the two.

data <- data %>%  mutate(...1= replace(...1, ...1=="PIA3" & ...2=="only_Inf",  "PIA3a" ),
                 ...1= replace(...1, ...1=="PIA3" & ...2=="only_Affx", "PIA3b" ))

# It is now modified in the new genomic dataset, so this chunk is not useful anymore. 
```


## Dataset with SNP IDs

I create a dataset with the different codes used to refer to the SNP markers: 

  - `original_ID` refers to the original SNP ID.
  
  - `affx_ID` refers to the ID from the Axiom assay (most recent genomic data). 
  
  - `infinium_ID` refers to the ID from the Illumina Infinium assay (older genomic data).

  - `snp_ID` is my own ID that I'm going to create for this paper.
  


```{r CodeDataset}
codes <- data[1:3,] %>% t() %>% as.data.frame() %>% as_tibble()
colnames(codes) <- c("original_ID","affx_ID","infinium_ID")
codes <- codes[-c(1,2),] %>% 
  mutate(snp_ID=paste0("snp_",1:nrow(.)))

# saveRDS(codes,file="data/GenomicData/FormattedData/SNPcodes.rds")

sapply(codes, function(x) sum(is.na(x)))
```

## Genomic data with all data

I create a dataset with all markers (rows) and clones (columns). 

```{r CreatingTotalGenomicDataset,eval=F}
sub <- data %>% 
  dplyr::select(-1,-2) %>%  # removing the first two columns corresponding to clone ID and assay(s) in which they were genotyped
  dplyr::slice(-c(1,2,3))   # removing the first three rows corresponding to the different SNP IDs

colnames(sub) <- codes$snp_ID # attributing the SNP ID I created to the SNPs

# Converting letters (e.g. A/A, A/G) to numbers (0,1 or 2)
list.alleles <- lapply(colnames(sub), function(x){
  
  vec <- sub[,x]
  
  tab <- table(sub[,x]) %>%  as.matrix() %>%  t() %>% as.data.frame() %>% dplyr::select(-contains("---"))
  
  
  if(length(colnames(tab))==1){ # monomorphic case, e.g. only A/A
    major <- names(which.max(tab))
    
    case_when(vec == major ~ 0) 
    
  } else if(length(colnames(tab))==2){ # case where there is no homozygote with the rare allele, e.g. A/A and A/G
    
    major <- names(which.max(tab))
    mid <- names(which.min(tab))
    
    case_when(vec == major ~ 0,
              vec == mid   ~ 1) 
    
  } else if (length(colnames(tab))==3){ # common case, e.g. A/A, A/G and G/G
    
    major <- names(which.max(tab))
    minor <- names(which.min(tab))
    mid <- setdiff(names(tab),c(major,minor))  
    
    case_when(vec == major ~ 0,
              vec == minor ~ 2,
              vec == mid   ~ 1) 
  }
})

names(list.alleles) <- colnames(sub) # reattribute the SNP ID to list names

df <- list.alleles %>% 
  as_tibble() %>% 
  t()

colnames(df) <- data[4:nrow(data),1] %>%  pull() # attribute clone ID

# saveRDS(df,file="data/GenomicData/FormattedData/TotalGenomicData.rds")
```

```{r, echo=F}
df <- readRDS(file="data/GenomicData/FormattedData/TotalGenomicData.rds")
```


We obtain a dataset of `r ncol(df)` clones (columns) and `r nrow(df)` SNP markers (rows). Here the 10 first rows and 15 first columns:

```{r ShowSubTotalGenomicDataset, echo=F}
df[1:10,1:15]  %>% 
  kable() %>%  
  kable_styling(font_size=11,
                bootstrap_options = c("stripped","hover", "condensed"), full_width = F)
```



# Filtering monomorphic SNPs

```{r IdentifyingMonomorphicSNPs}
mono <- df %>% 
  t() %>% 
  as_tibble() %>% 
  sapply(function(x) sum(x,na.rm=T)) %>% 
  as.data.frame() %>%
  set_colnames(c("sum")) %>% 
  rownames_to_column(var = "snp") %>% 
  as_tibble() %>% 
  filter(sum==0)
```

There are `r nrow(mono)` monomorphic SNPs. I'm going to remove them.


```{r RemovingMonomorphicSNPs}
df <- df[!(row.names(df) %in% mono$snp),]
```

<span style="color: red;">There are `r nrow(df)` SNPs left.</span>


# Identifying duplicates

The first way to identify the duplicated SNPs is by using the function `duplicated`. 

```{r IdentifyPerfectDuplicates}
dup <- df[duplicated(df) | duplicated(df, fromLast=TRUE), ]
```

There are `r nrow(dup)` duplicates (=SNPs that have exactly the same genotype as at least one other SNP).

We can try to determine how many copies there are for each duplicate. 

```{r CountCopiesDuplicates}
count.duplicates <- function(DF){
  x <- do.call('paste', c(DF, sep = '\r'))
  ox <- order(x)
  rl <- rle(x[ox])
  cbind(DF[ox[cumsum(rl$lengths)],,drop=FALSE],count = rl$lengths)
  
}
countdup <- count.duplicates(df %>% as.data.frame()) 
table(countdup$count)
```

This is relevant with what we found before as:

```{r}
2*91 + 3*12 + 4 + 5
```

So it means that there are:

  - <span style="color: red;"> 91 pairs of duplicate SNPs.</span>
  - <span style="color: red;"> 12 groups of 3 duplicate SNPs.</span>
  - <span style="color: red;"> 1 group of 4 duplicate SNPs.</span>
  - <span style="color: red;"> 1 group of 5 duplicate SNPs.</span>

But, there are two situations not accounted for by the function `duplicated`. 

  - First, if two SNPs have exactly the same genotype for all clones, except one clone where one of the two SNPs has a value of "1" for instance, and the other SNP has the value "NA". In this case, the two SNPs will not be considered as duplicates. 
  - Second, if the two SNPs covary perfectly but one have "0" when the other have "2", and vice versa, they will not be counted as duplicates neither. For instance:
      - SNP_1: 0 0 1 1 2 2 
      - SNP_2: 2 2 1 1 0 0 

To add these situations in the count of duplicated SNPs, I selected all the pairs of SNPs with a correlation coefficient of 1. 

```{r IdentifyCorrelatedSNPs,eval=F}
# Invert the genomic matrix
tdf <- df %>% t() %>% as.data.frame() 

# Create a matrix of correlation for all SNPs (5165snps x 5165snps)
matcor <- cor(tdf, use = "pairwise.complete.obs")
matcor[1:10,1:10] %>% 
  kable() %>%  
  kable_styling(bootstrap_options = c("stripped","hover", "condensed"), full_width = F)

# Keep only the upper triangle of the matrix and remove values in the diagnonal
matcor[lower.tri(matcor,diag=T)] <- NA
matcor[1:10,1:10] %>% 
  kable() %>%  
  kable_styling(bootstrap_options = c("stripped","hover", "condensed"), full_width = F)

saveRDS(matcor,file="data/GenomicData/FormattedData/CorrelationMatrixAmongMarkers.rds")

# Counting the number of pairs of SNPs that have a correlation coefficient of 1
length(which(matcor==1))
```


<span style="color: red;">2160 pairs of SNPs have a correlation coefficient of 1.</span>

```{r NamesCorrelatedSNPs,eval=F}
matcor <- readRDS(file="data/GenomicData/FormattedData/CorrelationMatrixAmongMarkers.rds")

# If I want to have the names of the SNPs that have a correlation coefficient of 1
snp.list <- reshape2::melt(matcor) %>% 
  filter(value == 1) %>% 
  dplyr::select(Var1, Var2) %>% 
  dplyr::rename(SNP1=Var1,SNP2=Var2) %>% 
  as_tibble()

# To check that these SNPs have the same genotypes (ignoring NAs) with the following command:
table(df[rownames(df)=="snp_46",],df[rownames(df)=="snp_73",])

# Merge with other SNPs codes
codes_SNP1 <- codes %>% dplyr::rename(SNP1=snp_ID,
                                      original_ID_SNP1=original_ID,
                                      affx_ID_SNP1=affx_ID,
                                      infinium_ID_SNP1=infinium_ID) 
codes_SNP2 <- codes %>% dplyr::rename(SNP2=snp_ID,
                                      original_ID_SNP2=original_ID,
                                      affx_ID_SNP2=affx_ID,
                                      infinium_ID_SNP2=infinium_ID) 

snp.list <- snp.list %>% 
  merge(codes_SNP1,by="SNP1") %>% 
  merge(codes_SNP2,by="SNP2")

# Export the list of SNPs with correlation coefficient of one 
write_csv(snp.list,"data/GenomicData/FormattedData/CorrelatedSnps.csv")
```


# Removing the ROD population

We remove the clones from the ROD (Rodoiros) populations, as they come from a plantation of material from Central Spain in the Iberian Atlantic region.

```{r RmROD}
df <- df %>% 
  as.data.frame() %>% 
  dplyr::select(-contains("ROD"))
```


# Filtering

## Missing data per clone

```{r MissingDataPerClone, warning=F, fig.height=6,fig.width=10}
tab <- df %>% 
  as_tibble() %>% 
  sapply(function(x) sum(is.na(x))*100/nrow(df)) %>% 
  as.data.frame() %>%
  set_colnames(c("freq.NAs")) %>% 
  rownames_to_column(var = "clone") %>% 
  as_tibble() %>% 
  arrange(freq.NAs) %>% 
  mutate(id=1:nrow(.))

plot(tab$id,tab$freq.NAs,
     pch=20,
     xlab="Clone number",
     ylab="Percentage of missing data per clone")
```

**<span style="color: red;">`r nrow(tab[tab$freq.NAs<20,])` clones have the percentage of missing data lower than 20% and `r nrow(tab[tab$freq.NAs<15,])` lower than 15%.</span>**

We are going to keep the `r nrow(tab[tab$freq.NAs<20,])` clones that have less than 20% missing data. 

```{r RemoveCloneMissingData}
df <- df %>% dplyr::select(tab[tab$freq.NAs<20,]$clone)
```

## Minor allele frequencies

```{r MAF, warning=F, fig.height=6,fig.width=10}
tab <- df %>% 
  t() %>% 
  as_tibble() %>% 
  sapply(function(x) sum(x,na.rm=T)*100/(2*nrow(.))) %>% 
  as.data.frame() %>%
  set_colnames(c("MAF")) %>% 
  rownames_to_column(var = "snp") %>% 
  as_tibble() %>% 
  arrange(MAF) %>% 
  mutate(id=1:nrow(.))

plot(tab$id,tab$MAF,
     pch=20,
     xlab="SNP number",
     ylab="Minor allele frequencies")
```

**<span style="color: red;">`r nrow(tab[tab$MAF<1,])` SNPs have MAF < 1%.</span>** 

We remove the SNPs with MAF < 1%.

```{r RmMissingDataMAF}
df <-  df[!(row.names(df) %in% tab[tab$MAF<1,]$snp),]   
```

**<span style="color: red;">There are `r nrow(df)` SNPs left.</span>** 


## Missing data per SNP

```{r MissingDataPerSNP, warning=F, fig.height=6,fig.width=10}
tab <- df %>% 
  t() %>% 
  as_tibble() %>% 
  sapply(function(x) sum(is.na(x))*100/nrow(.)) %>% 
  as.data.frame() %>%
  set_colnames(c("freq.NAs")) %>% 
  rownames_to_column(var = "snp") %>% 
  as_tibble() %>% 
  arrange(freq.NAs) %>% 
  mutate(id=1:nrow(.))

plot(tab$id,tab$freq.NAs,
     pch=20,
     xlab="SNP number",
     ylab="Percentage of missing data per SNP")
```


`r nrow(tab[tab$freq.NAs<20,])` SNPs have the percentage of missing data lower than 20% and `r nrow(tab[tab$freq.NAs<15,])` lower than 15%.

```{r RmMissingDataSNPs}
df <- df[(row.names(df) %in% tab[tab$freq.NAs<20,]$snp),]
```

**<span style="color: red;">We keep SNPs with missing data lower than 20% and so there are `r nrow(df)` SNPs left.</span>**

# Export the genomic data

```{r ExportGenomicDataRDS}
nsnp <- nrow(df)
nclone <- ncol(df)

saveRDS(df,
        paste0("data/GenomicData/FormattedData/GenomicData_",nclone,"clones_",nsnp,"snps.rds"))
```


```{r ExportGenomicDataCSV}
df <- codes %>% 
  merge(df %>% rownames_to_column(var="snp_ID"),by="snp_ID") %>% 
  dplyr::rename(juliette_snp_ID=snp_ID)

write_csv(df,
        paste0("data/GenomicData/FormattedData/GenomicData_",nclone,"clones_",nsnp,"snps.csv"),
        append=FALSE)
```


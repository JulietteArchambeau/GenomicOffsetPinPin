---
title: "Gradient Forest"
author: "Juliette Archambeau"
date: "17 juillet 2020"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
---


<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=F)
options(width = 300)
library(knitr)
library(dplyr)
library(tidyverse)
library(raster)
library(adespatial)
library(gradientForest) # install.packages("gradientForest", repos="http://R-Forge.R-project.org")
```

# Comments

- warning when running the models: "Warning in randomForest.default(m, y, ...): The response has five or fewer unique values. Are you sure you want to do regression?" In `?gradientForest`, " If the species are numeric variables, a regression forest is calculated. If the species are factor variables, a classification forest is calculated."

# Loading and preparing data


> Provenance coordinates

```{r ProvCoordExtract}
xy <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
xy <- unique(xy[,c("prov","longitude_prov","latitude_prov")])
xy <- xy[!(xy$prov=="ROD"),]
colnames(xy) <- c("prov","longitude","latitude")
```

> Calculate the Moran's eigenvectors

```{r MoranEigenVectors}
mem <- dbmem(xy[,2:3]) 

# Merge coordinates and MEM
mem <- bind_cols(xy,mem)
mem
```

> Loading soil, climatic and altitude data (point estimates at each provenance location)

```{r ClimSoilAltData}
data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
data <- data %>% dplyr::select(contains("prov"))
data <- unique(data)
data <- data[!(data$prov=="ROD"),]
data
```

> Sets of climatic variables

```{r SetsClimaticVariables}
# Set 1
select.var1 <- c(paste0("bio",c(1,5,12,14),"_prov"),"sand_top_prov","depth_roots_prov")

# Set 2
select.var2 <- c("bio1_prov","bio12_prov","bio6_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")

# Set 3
select.var3 <- c("bio1_prov","bio14_prov","ppet.mean_prov","sand_top_prov","depth_roots_prov")

# Set 4
select.var4 <- c("bio1_prov","bio14_prov","ppet.mean_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")

# Set 5
select.var5 <- c("bio13_prov","bio14_prov","bio5_prov","bio6_prov","sand_top_prov","depth_roots_prov")
```

> Load and prepare genomic data

```{r GenomicDataMunging,eval=F}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

rm(geno_names)

geno <-  as_tibble(t(geno), rownames = "rownames") %>% 
  mutate(rownames=str_sub(rownames,1,3)) %>% 
  dplyr::rename(prov = rownames) %>% 
  group_by(prov) %>% 
  summarise_all(~sum(., na.rm = TRUE)/(n()*2))

saveRDS(geno,file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequencies.rds")
```

```{r LoadGenoPrepared,echo=F}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequencies.rds")
```

> Maritime pine distribution (mask for the raster of predictions)

```{r LoadPinPinasterDistri}
# Load maritime pine distribution from EUFORGEN (shapefile)
shp  <- shapefile('../../../../Pinpin_Clonapin/maps/pinus_pinaster_distribution/Pinus_pinaster_EUFORGEN.shp')
```


# Set 1

## With altitude

```{r VarSet1Alt}
select.var <- select.var1
model.name <- "gfSet1Alt"
stack.name <- "StackAltSoilClimSet1"
```


```{r GFSet1Alt,eval=F}
subdata <- data[,c("prov",select.var, "altitude_prov")]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var,"altitude_prov"),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```




```{r LoadGFSet1Alt, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet1Alt, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet1Alt, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

## Without altitude


```{r VarSet1}
select.var <- select.var1
model.name <- "gfSet1"
stack.name <- "StackSoilClimSet1"
```

```{r GFSet1,eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet1, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet1, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet1, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```


# Set 2

## With altitude

```{r VarSet2Alt}
select.var <- select.var2
model.name <- "gfSet2Alt"
stack.name <- "StackAltSoilClimSet2"
```


```{r GFSet2Alt,eval=F}
subdata <- data[,c("prov",select.var, "altitude_prov")]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var,"altitude_prov"),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet2Alt, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet2Alt, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet2Alt, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

## Without altitude

```{r VarSet2}
select.var <- select.var2
model.name <- "gfSet2"
stack.name <- "StackSoilClimSet2"
```

```{r GFSet2,eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet2, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet2, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet2, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```



# Set 5

## Without altitude

### Current climate 

```{r VarSet5}
select.var <- select.var5
model.name <- "gfSet5"
stack.name <- "StackSoilClimSet5"
stack.name.fut <- "FutClimStackSoilClimSet5"
```

```{r GFSet5, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet5, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet5, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet5, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

### Future climate


```{r MappingOutputsSet5FutClim, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name.fut,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
predFut <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

### Genomic offset

```{r GenomicOffsetSet5}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,"LowRes.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming


# calculate euclidean distance between current and future genetic spaces  
genOff <- sqrt((projCur[,1]-predFut[,1])^2+(projCur[,2]-predFut[,2])^2
                    +(projCur[,3]-predFut[,3])^2+(projCur[,4]-predFut[,4])^2
                    +(projCur[,5]-predFut[,5])^2+(projCur[,6]-predFut[,6])^2)


# assign values to raster - can be tricky if current/future climate
# rasters are not identical in terms of # cells, extent, etc.
values <- raster::extract(stackall, shp,cellnumbers=T)

rastt<- stackall[[1]]
rastt[rasValue$cell] <- genOff
plot(rastt)
```


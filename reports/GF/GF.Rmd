---
title: "Gradient Forest"
author: "Juliette Archambeau"
date: "17 juillet 2020"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
---


<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=T)
options(width = 300)
library(knitr)
library(dplyr)
library(tidyverse)
library(raster)
library(adespatial)
library(gradientForest) # install.packages("gradientForest", repos="http://R-Forge.R-project.org")
```

> Comments

- warning when running the models: "Warning in randomForest.default(m, y, ...): The response has five or fewer unique values. Are you sure you want to do regression?" In `?gradientForest`, " If the species are numeric variables, a regression forest is calculated. If the species are factor variables, a classification forest is calculated."

```{r Functions}
PredictAcrossRange <- function(x){
  
  rasValue <- raster::extract(x, shp,cellnumbers=T)
  rasValue <- as.data.frame(rasValue)
  rasValue <- na.omit(rasValue)
  
  # transform env using gf models, see ?predict.gradientForest
  predFut <- predict(gf, rasValue[,-1])
  
  # calculate euclidean distance between current and future genetic spaces  
  return(sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2))
}
```


# BEFORE SELECTION

## Loading and preparing data


> Provenance coordinates

```{r ProvCoordExtract}
xy <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
xy <- unique(xy[,c("prov","longitude_prov","latitude_prov")])
xy <- xy[!(xy$prov=="ROD"),]
colnames(xy) <- c("prov","longitude","latitude")
```

> Calculate the Moran's eigenvectors

```{r MoranEigenVectors}
mem <- dbmem(xy[,2:3]) 

# Merge coordinates and MEM
mem <- bind_cols(xy,mem)
mem
```

> Loading soil, climatic and altitude data (point estimates at each provenance location)

```{r ClimSoilAltData}
data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
data <- data %>% dplyr::select(contains("prov"))
data <- unique(data)
data <- data[!(data$prov=="ROD"),]
data
```

> Sets of climatic variables

```{r SetsClimaticVariables}
# Set 1
select.var1 <- c(paste0("bio",c(1,5,12,14),"_prov"),"sand_top_prov","depth_roots_prov")

# Set 2
select.var2 <- c("bio1_prov","bio12_prov","bio6_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")

# Set 3
select.var3 <- c("bio1_prov","bio14_prov","ppet.mean_prov","sand_top_prov","depth_roots_prov")

# Set 4
select.var4 <- c("bio1_prov","bio14_prov","ppet.mean_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")

# Set 5
select.var5 <- c("bio13_prov","bio14_prov","bio5_prov","bio6_prov","sand_top_prov","depth_roots_prov")
```

> Load and prepare genomic data

```{r GenomicDataMunging,eval=F}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

rm(geno_names)

geno <-  as_tibble(t(geno), rownames = "rownames") %>% 
  mutate(rownames=str_sub(rownames,1,3)) %>% 
  dplyr::rename(prov = rownames) %>% 
  group_by(prov) %>% 
  summarise_all(~sum(., na.rm = TRUE)/(n()*2))

saveRDS(geno,file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequencies.rds")
```

```{r LoadGenoPrepared,echo=F}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequencies.rds")
```

> Maritime pine distribution (mask for the raster of predictions)

```{r LoadPinPinasterDistri}
# Load maritime pine distribution from EUFORGEN (shapefile)
shp  <- shapefile('../../../../Pinpin_Clonapin/maps/pinus_pinaster_distribution/Pinus_pinaster_EUFORGEN.shp')
```


## Set 1

### With altitude

```{r VarSet1Alt}
select.var <- select.var1
model.name <- "gfSet1Alt"
stack.name <- "StackAltSoilClimSet1"
```


```{r GFSet1Alt,eval=F}
subdata <- data[,c("prov",select.var, "altitude_prov")]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var,"altitude_prov"),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet1Alt, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet1Alt, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet1Alt, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

### Without altitude

```{r VarSet1}
select.var <- select.var1
model.name <- "gfSet1"
stack.name <- "StackSoilClimSet1"
```

```{r GFSet1,eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet1, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet1, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet1, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```


## Set 2

### With altitude

```{r VarSet2Alt}
select.var <- select.var2
model.name <- "gfSet2Alt"
stack.name <- "StackAltSoilClimSet2"
```


```{r GFSet2Alt,eval=F}
subdata <- data[,c("prov",select.var, "altitude_prov")]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var,"altitude_prov"),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet2Alt, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet2Alt, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet2Alt, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

### Without altitude

```{r VarSet2}
select.var <- select.var2
model.name <- "gfSet2"
stack.name <- "StackSoilClimSet2"
```

```{r GFSet2,eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet2, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet2, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet2, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```



## Set 5

### Without altitude

#### Current climate 

```{r VarSet5}
select.var <- select.var5
model.name <- "gfSet5"
stack.name <- "StackSoilClimSet5"
stack.name.fut <- "FutClimStackSoilClimSet5"
```

```{r GFSet5, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet5, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet5, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet5, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Future climate

```{r MappingOutputsSet5FutClim, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name.fut,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
predFut <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Genomic offset

```{r GenomicOffsetSet5}
stackall <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/",stack.name,"ResWorldClim.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCurResWorldClim <- predict(gf, rasValue[,-1]) # remove cell column before transforming


# calculate euclidean distance between current and future genetic spaces  
genOffBS <- sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2)


# assign values to raster - can be tricky if current/future climate
# rasters are not identical in terms of # cells, extent, etc.
values <- raster::extract(stackall, shp,cellnumbers=T)

rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- genOffBS
plot(rast.go)
```


#### Future climate - All GCMs (SSP370)


```{r Set5BeforeSelectionFutClimAllGCMsCalculateGO}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, PredictAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5BeforeSelectionFutClimAllGCMsPlots, fig.height=5,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Keeping mean and SD for futher analyses
DFtot <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanBS=mean,SdBS=sd)
```

# AFTER SELECTION in Madrid and Caceres

Here we remove the genotypes for which no individual has survived neither in Madrid nor in Cáceres. 

## Loading new genotypic frequencies

> Extracting the genotype names to be selected 

```{r ExtractGenotypeNamesCacMad}
temp.data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")

# Removing genotypes for which there is no genomic data
temp.data <- temp.data[!(is.na(temp.data$Q1)),]

# Keep only data from Caceres and Madrid (the dry sites) 
temp.data <- temp.data[temp.data$site=="caceres"|temp.data$site=="madrid",]

# Keep only survivors
temp.data <- temp.data[temp.data$survival==1,]

# Vectors of genotypes for which at least one indivdual survive to drought
geno.names.sub <- unique(temp.data$clon)
rm(temp.data)

# How many genotypes?
length(geno.names.sub)
```


> Load and prepare new genomic data

```{r GenomicNewDataMungingCacMad,eval=F}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

rm(geno_names)

# Select only genotypes which has at least one survivor
geno <- geno %>% dplyr::select(all_of(geno.names.sub))

geno <-  as_tibble(t(geno), rownames = "rownames") %>% 
  mutate(rownames=str_sub(rownames,1,3)) %>% 
  dplyr::rename(prov = rownames) %>% 
  group_by(prov) %>% 
  summarise_all(~sum(., na.rm = TRUE)/(n()*2))

saveRDS(geno,file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacMad.rds")
```

```{r LoadNewGenoPreparedCacMad,echo=F}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacMad.rds")
```


## Set 5

### Without altitude

#### Current climate 

```{r VarSet5AfterSelectionCacMad}
select.var <- select.var5
model.name <- "gfSet5AfterSelectionCacMad"
stack.name <- "StackSoilClimSet5"
stack.name.fut <- "FutClimStackSoilClimSet5"
```

```{r GFSet5AfterSelectionCacMad, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

Lots of warnings: "The response has five or fewer unique values.  Are you sure you want to do regression?"
Some info here: https://nickfountainjones.wordpress.com/tag/r/

```{r LoadGFSet5AfterSelectionCacMad, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet5AfterSelectionCacMad, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet5AfterSelectionCacMad, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Future climate (SSP245)

```{r MappingOutputsSet5FutClimAfterSelectionCacMad, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name.fut,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
predFut <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Genomic offset

```{r GenomicOffsetSet5AfterSelectionCacMad}
stackall <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/",stack.name,"ResWorldClim.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCurResWorldClim <- predict(gf, rasValue[,-1]) # remove cell column before transforming


# calculate euclidean distance between current and future genetic spaces  
genOffAScacmad <- sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2)


# assign values to raster - can be tricky if current/future climate
# rasters are not identical in terms of # cells, extent, etc.
values <- raster::extract(stackall, shp,cellnumbers=T)

rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- genOffAScacmad
plot(rast.go)
```


#### Future climate - All GCMs (SSP370)


```{r Set5AfterSelectionCacMadFutClimAllGCMsCalculateGO}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, PredictAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5AfterSelectionCacMadFutClimAllGCMsPlots, fig.height=5,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Keeping mean and SD for futher analyses
dfGOallGCMs <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanASmadcac=mean,SdASmadcac=sd)
DFtot <- bind_cols(DFtot,dfGOallGCMs)
```


# AFTER SELECTION in Caceres

## Loading new genotypic frequencies

> Extracting the genotype names to be selected 

```{r ExtractGenotypeNamesCacOnly}
temp.data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")

# Removing genotypes for which there is no genomic data
temp.data <- temp.data[!(is.na(temp.data$Q1)),]

# Keep only data from Caceres and Madrid (the dry sites) 
temp.data <- temp.data[temp.data$site=="caceres",]

# Keep only survivors
temp.data <- temp.data[temp.data$survival==1,]

# Vectors of genotypes for which at least one indivdual survive to drought
geno.names.sub <- unique(temp.data$clon)
rm(temp.data)

# How many genotypes?
length(geno.names.sub)
```


> Load and prepare new genomic data

```{r GenomicNewDataMungingCacOnly, eval=F}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

rm(geno_names)

# Select only genotypes which has at least one survivor
geno <- geno %>% dplyr::select(all_of(geno.names.sub))

geno <-  as_tibble(t(geno), rownames = "rownames") %>% 
  mutate(rownames=str_sub(rownames,1,3)) %>% 
  dplyr::rename(prov = rownames) %>% 
  group_by(prov) %>% 
  summarise_all(~sum(., na.rm = TRUE)/(n()*2))

saveRDS(geno,file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacOnly.rds")
```

```{r LoadNewGenoPreparedCacOnly,echo=F}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacOnly.rds")
```


## Set 5

### Without altitude

#### Current climate 

```{r VarSet5AfterSelectionCacOnly}
select.var <- select.var5
model.name <- "gfSet5AfterSelectionCacOnly"
stack.name <- "StackSoilClimSet5"
stack.name.fut <- "FutClimStackSoilClimSet5"
```

```{r GFSet5AfterSelectionCacOnly, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```



Lots of warnings: "The response has five or fewer unique values.  Are you sure you want to do regression?"
Some info here: https://nickfountainjones.wordpress.com/tag/r/

```{r LoadGFSet5AfterSelectionCacOnly, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet5AfterSelectionCacOnly, fig.height=6,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Cumulative.Importance")
#plot(gf, plot.type="Cumulative.Importance",plot.args = list(impt.vars=c("bio14","bio5")))
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet5AfterSelectionCacOnly, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Future climate

```{r MappingOutputsSet5FutClimAfterSelectionCacOnly, fig.height=11,fig.width=14}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name.fut,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
predFut <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Genomic offset

```{r GenomicOffsetSet5AfterSelectionCacOnly}
stackall <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/",stack.name,"ResWorldClim.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCurResWorldClim <- predict(gf, rasValue[,-1]) # remove cell column before transforming


# calculate euclidean distance between current and future genetic spaces  
genOffAScac <- sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2)


# assign values to raster - can be tricky if current/future climate
# rasters are not identical in terms of # cells, extent, etc.
values <- raster::extract(stackall, shp,cellnumbers=T)

rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- genOffAScac
plot(rast.go)
```
  
```{r ComparingBeforeAndAfterSelectionSet5CacOnly,fig.width=9}
GO <- data.frame(BS=genOffBS,AS=genOffAScacmad, AScac=genOffAScac)
GO <- GO %>%  pivot_longer(cols=everything(),names_to="subset",values_to="go")
ggplot(GO, aes(x=go,color=subset)) + 
  geom_density(size=1.5) +
  theme_bw() + 
  xlab("Genomic offset") +
  scale_color_discrete(name = "Subset of\n genotypes", labels = c("After selection in Madrid and Caceres","After selection in Caceres","Before Selection"))


ggplot(GO, aes(x=subset, y=go, fill=subset)) + 
  geom_boxplot(alpha=0.6) + 
  theme_bw() +
  scale_fill_discrete(name = "Subset of\n genotypes", labels = c("After selection in Madrid and Caceres","After selection in Caceres","Before Selection")) +
  ylab("Genomic offset") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```


#### Future climate - All GCMs (SSP370)


```{r Set5AfterSelectionCacOnlyFutClimAllGCMsCalculateGO}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, PredictAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5AfterSelectionCacOnlyFutClimAllGCMsPlots, fig.height=5,fig.width=10}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Comparing with BeforeSelection and AfterSelectionCacMad
dfGOallGCMs <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanAScac=mean,SdAScac=sd)
DFtot <- bind_cols(DFtot,dfGOallGCMs)

DFtot %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=go,color=subset)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")  +
    scale_color_discrete(name = "Subset of\n genotypes", labels = c("After selection in Caceres",
                                                                    "After selection in Madrid and Caceres",
                                                                    "Before Selection"))
DFtot %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=subset, y=go, fill=subset)) + 
    geom_boxplot(alpha=0.6) + 
    theme_bw() +
    scale_fill_discrete(name = "Subset of\n genotypes",
                      labels = c("After selection in Caceres",
                                 "After selection in Madrid and Caceres",
                                 "Before Selection")) +
    ylab("Genomic offset") +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

To show se instead of sd in the barplots: https://stackoverflow.com/questions/25999677/how-to-plot-mean-and-standard-error-in-boxplot-in-r


`r knitr::opts_chunk$set(eval = F)`
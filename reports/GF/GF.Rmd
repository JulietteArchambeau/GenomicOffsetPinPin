---
title: "Gradient Forest"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
---


<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=T)
options(width = 300)
library(knitr)
library(plyr)
library(dplyr)
library(tidyverse)
library(raster)
library(adespatial)
library(gradientForest) # install.packages("gradientForest", repos="http://R-Forge.R-project.org")
library(vegan)
```

All these analyses are based on the paper of [Fitzpatrick and Keller (2014)](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12376). 

https://www.biorxiv.org/content/10.1101/871251v1.full


> Comments

- warning when running the models: "Warning in randomForest.default(m, y, ...): The response has five or fewer unique values. Are you sure you want to do regression?" In `?gradientForest`, " If the species are numeric variables, a regression forest is calculated. If the species are factor variables, a classification forest is calculated."

```{r Functions}
GOAcrossRange <- function(x){
  
  rasValue <- raster::extract(x, shp,cellnumbers=T)
  rasValue <- as.data.frame(rasValue)
  rasValue <- na.omit(rasValue)
  
  # transform env using gf models, see ?predict.gradientForest
  predFut <- predict(gf, rasValue[,-1])
  
  # calculate euclidean distance between current and future genetic spaces  
  return(sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2))
}

VarImptanceAcrossRange <- function(x){
  
  rasValue <- raster::extract(x, shp,cellnumbers=T)
  rasValue <- as.data.frame(rasValue)
  rasValue <- na.omit(rasValue)
  
  # transform env using gf models, see ?predict.gradientForest
  return(predict(gf, rasValue[,-1]))
  
}
```


> Hillshade (background)

```{r GrayScale}
# Gray scale
grayscale_colors <- gray.colors(100,            # number of different color levels
                                start = 0.0,    # how black (0) to go
                                end = 1.0,      # how white (1) to go
                                gamma = 2.2,    # correction between how a digital
                                # camera sees the world and how human eyes see it
                                alpha = NULL)
```

```{r MapBackground}
# fond de carte
# https://land.copernicus.eu/imagery-in-situ/eu-dem/eu-dem-v1-0-and-derived-products/slope?tab=download
# Need to create an account

# I took the hillsahede map from here:
# https://www.eea.europa.eu/data-and-maps/data/digital-elevation-model-of-europe

background <- raster("../../data/maps/EuropeanData/hillshade1x1.tif")
background <- projectRaster(background, crs="+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
e <- extent(-10, 14, 31, 46)
background <- crop(background, e)

# text(9,32,"Potentiels refuges climatiques\ndes pois chiches\n lors du réchauffement climatique")
```


# BEFORE SELECTION

## Loading and preparing data


> Provenance coordinates

```{r ProvCoordExtract}
xy <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
xy <- unique(xy[,c("prov","longitude_prov","latitude_prov")])
xy <- xy[!(xy$prov=="ROD"),]
colnames(xy) <- c("prov","longitude","latitude")
```

> Calculate the Moran's eigenvectors

```{r MoranEigenVectors}
mem <- dbmem(xy[,2:3]) 

# Merge coordinates and MEM
mem <- bind_cols(xy,mem)
mem
```

> Loading soil, climatic and altitude data (point estimates at each provenance location)

```{r ClimSoilAltData}
data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
data <- data %>% dplyr::select(contains("prov"))
data <- unique(data)
data <- data[!(data$prov=="ROD"),]
data
```

> Sets of climatic variables

```{r SetsClimaticVariables}
# Set 1
select.var1 <- c(paste0("bio",c(1,5,12,14),"_prov"),"sand_top_prov","depth_roots_prov")

# Set 2
select.var2 <- c("bio1_prov","bio12_prov","bio6_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")

# Set 3
select.var3 <- c("bio1_prov","bio14_prov","ppet.mean_prov","sand_top_prov","depth_roots_prov")

# Set 4
select.var4 <- c("bio1_prov","bio14_prov","ppet.mean_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")

# Set 5
select.var5 <- c("bio13_prov","bio14_prov","bio5_prov","bio6_prov","sand_top_prov","depth_roots_prov")
```

> Load and prepare genomic data


```{r LoadGenoPrepared,echo=F}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequencies.rds")
```

```{r RmMinorAlleleFrequencies}
vec <- apply(geno[,-1],2,function(x) length(unique(x)))
vecsup <- vec[vec>5]
snps <- names(vecsup)
length(vecsup) # Number of SNPs polymorphic in > 5 populations
ncol(geno[,-1]) - length(vecsup) # Number of SNPs polymorphic in less than or equal to 5 populations
genoMAF <- geno %>% dplyr::select(contains(c("prov",snps)))
```


> Maritime pine distribution (mask for the raster of predictions)

```{r LoadPinPinasterDistri}
# Load maritime pine distribution from EUFORGEN (shapefile)
shp  <- shapefile('../../../../Pinpin_Clonapin/maps/pinus_pinaster_distribution/Pinus_pinaster_EUFORGEN.shp')
```


## Set 1

### With altitude

```{r VarSet1Alt}
select.var <- select.var1
model.name <- "gfSet1Alt"
stack.name <- "StackAltSoilClimSet1"
```


```{r GFSet1Alt,eval=F}
subdata <- data[,c("prov",select.var, "altitude_prov")]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var,"altitude_prov"),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet1Alt, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet1Alt, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet1Alt, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

### Without altitude

```{r VarSet1}
select.var <- select.var1
model.name <- "gfSet1"
stack.name <- "StackSoilClimSet1"
```

```{r GFSet1,eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet1, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet1, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
#plot(gf, plot.type="Split.Density")
#plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet1, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```


## Set 2

### With altitude

```{r VarSet2Alt}
select.var <- select.var2
model.name <- "gfSet2Alt"
stack.name <- "StackAltSoilClimSet2"
```


```{r GFSet2Alt,eval=F}
subdata <- data[,c("prov",select.var, "altitude_prov")]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var,"altitude_prov"),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet2Alt, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet2Alt, fig.height=5,fig.width=8}
plot(gf, plot.type="Overall.Importance")
# plot(gf, plot.type="Split.Density")
# plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet2Alt, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

### Without altitude

```{r VarSet2}
select.var <- select.var2
model.name <- "gfSet2"
stack.name <- "StackSoilClimSet2"
```

```{r GFSet2,eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r LoadGFSet2, echo=F}
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r PlotGFSet2, fig.height=5,fig.width=8}
plot(gf, plot.type="Overall.Importance")
# plot(gf, plot.type="Split.Density")
# plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet2, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```



## Set 5

### Without altitude

#### Current climate (Fitting the models and projecting)

```{r VarSet5}
select.var <- select.var5
model.name <- "gfSet5"
stack.name <- "StackSoilClimSet5"
```

> Fitting the models

Here, we fit the model with all SNPs. But there are lots of warnings "The response has five or fewer unique values.  Are you sure you want to do regression?". This means that some alleles do not have enough unique values and the model estimation might not be robust.

```{r GFSet5, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

In this model, we removed alleles with five or fewer unique values, to ensure a more robust regression. Like in Fitzpatrick and Keller: "For GF, we converted the SNP data into minor allele relative frequencies and removed any SNP that was polymorphic in fewer than five of the 31 populations to ensure robust regression".

```{r GFSet5MAF, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,genoMAF,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,"MAF.rds"))
```

https://rpubs.com/javivi77/gradientforrestEMP

```{r LoadGFSet5, echo=F}
# Load model with all SNPs
# gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))

# Load models in which SNPs that were polymorphic in fewer than five of the 34 populations were removed to ensure robust regression 
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,"MAF.rds"))
```

```{r PlotGFSet5, fig.height=4,fig.width=8}
plot(gf, plot.type="Overall.Importance")
plot(gf, plot.type="Split.Density")
plot(gf, plot.type="Cumulative.Importance",
     imp.vars=c("bio13","bio14"),
     plot.args=list(show.species=FALSE,show.overall=TRUE))
plot(gf, plot.type="Performance")
plot(gf, plot.type = "P", show.names = T, horizontal = F,cex.axis = 1, cex.labels = 0.6, line = 2.5)
mean(gf$result)
sd(gf$result)
```

> Projecting across the species range

```{r MappingOutputsSet5, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(outRast, r = 1, g = 2, b = 3,add=T,bgalpha=0)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

> Biplot of the genetic space

```{r BiplotGeneticSpaceSet5, echo=F}
nvs <- dim(pca$rotation)[1]
vec <- names(gf$X)[5:10]
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 40
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1

plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+",cex=3,col="black")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


# Show the provenances
PredsProvs <- predict(gf)
PCprovs <- predict(pca, PredsProvs)
points(PCprovs[, 1:2])

# Show the alleles
SpsWtd <- sweep(gf$Y, 2, apply(gf$Y, 2, min),  "-")
SpsWtdPCs <- (t(SpsWtd) %*% (PCprovs[, 1:2]))/colSums(SpsWtd)
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 3, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(SpsWtdPCs, pch = ".",cex=3,col="black") # col = alpha("black", 0.4)

# Show some alleles
snp <- "SNP_0008"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)

snp <- "SNP_0109"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x10")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*10)


snp <- "SNP_6088"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)
```

From here: https://gradientforest.r-forge.r-project.org/biodiversity-survey.pdf

#### Future climate (2041-2060) - GCM BCC-CSM2-MR (SSP245)

I don't know if I have to predict with the option `extrap=TRUE` or not. In their script, Fitzpatrick and Keller do not use this option (default). 

```{r MappingOutputsSet5FutClim, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP245/",stack.name,"_BCCCSM2MR.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
predFut <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 2, b = 3)
# plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

> Biplot of the genetic space

```{r BiplotGeneticSpaceSet5FutClim, echo=F}
nvs <- dim(pca$rotation)[1]
vec <- names(gf$X)[5:10]
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 40
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+",cex=3,col="black")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


# Show the provenances
PredsProvs <- predict(gf)
PCprovs <- predict(pca, PredsProvs)
points(PCprovs[, 1:2])

# Show the alleles
SpsWtd <- sweep(gf$Y, 2, apply(gf$Y, 2, min),  "-")
SpsWtdPCs <- (t(SpsWtd) %*% (PCprovs[, 1:2]))/colSums(SpsWtd)
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 3, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(SpsWtdPCs, pch = ".",cex=3,col="black") # col = alpha("black", 0.4)

# Show some alleles
snp <- "SNP_0008"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)

snp <- "SNP_0109"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x10")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*10)


snp <- "SNP_6088"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)
```

> Genomic offset

```{r GenomicOffsetSet5,fig.height=6,fig.width=8}
stackall <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/",stack.name,"ResWorldClim.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCurResWorldClim <- predict(gf, rasValue[,-1]) # remove cell column before transforming


# calculate euclidean distance between current and future genetic spaces  
genOffBS <- sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2)


rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- genOffBS

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plot(rast.go,add=T,bgalpha=0)
```


#### Future climate (2041-2060) - All GCMs (SSP370)

Load the stacks (no need to have all the explanatory variables in the stack):

```{r LoadStackSet5BeforeSelectionFutClimAllGCMsCalculateGoSSP370}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP370/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))
```


Predictions across the range:

```{r Set5BeforeSelectionFutClimAllGCMsPredictionsAcrossRangeSSP370, echo=F}
# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, VarImptanceAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

genOffallGCMs <- aaply(laply(genOffallGCMs, as.matrix), c(2, 3), mean)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 2, b = 3)
# plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)

nvs <- dim(pca$rotation)[1]
vec <- names(gf$X)[5:10]
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 40
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+",cex=3,col="black")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)


# Show the provenances
PredsProvs <- predict(gf)
PCprovs <- predict(pca, PredsProvs)
points(PCprovs[, 1:2])

# Show the alleles
SpsWtd <- sweep(gf$Y, 2, apply(gf$Y, 2, min),  "-")
SpsWtdPCs <- (t(SpsWtd) %*% (PCprovs[, 1:2]))/colSums(SpsWtd)
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 3, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(SpsWtdPCs, pch = ".",cex=3,col="black") # col = alpha("black", 0.4)

# Show some alleles
snp <- "SNP_0008"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)

snp <- "SNP_0109"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x10")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*10)


snp <- "SNP_6088"
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1,
     main="x30")
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec,cex=1.5)
points(PCprovs[, 1:2], col = "blue", cex = SpsWtd[,snp]*30)
```

Calculate the GO:

```{r Set5BeforeSelectionFutClimAllGCMsCalculateGoSSP370}
# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5BeforeSelectionFutClimAllGCMsPlotsSSP370, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Keeping mean and SD for futher analyses
DFtot <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanBS=mean,SdBS=sd)
```

```{r PlotGOSet5BeforeSelectionFutClimAllGCMsSSP370,fig.height=6,fig.width=8}
rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- dfGOallGCMs$mean
plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plot(rast.go,box = FALSE,
     axes = FALSE,
     #alpha=0.8,
      col=colorRampPalette(c("blue","yellow","red"))(255),
     #zlim=c(0,0.1),
     add=T,
     bgalpha=0)
```


#### Future climate (2041-2060) - All GCMs (SSP585)


```{r Set5BeforeSelectionFutClimAllGCMsCalculateGoSSP585}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP585/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5BeforeSelectionFutClimAllGCMsPlotsSSP585, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Keeping mean and SD for futher analyses
DFtotssp585 <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanBS=mean,SdBS=sd)
```

```{r PlotGOSet5BeforeSelectionFutClimAllGCMsSSP585,fig.height=6,fig.width=8}
rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- dfGOallGCMs$mean
plot(rast.go)
```


# AFTER SELECTION in Madrid and Caceres

Here we remove the genotypes for which no individual has survived neither in Madrid nor in Cáceres. 

## Loading new genotypic frequencies

> Extracting the genotype names to be kept

```{r ExtractGenotypeNamesCacMad}
geno.names.sub <- readRDS(file="../../data/PreparedDFforGDMandGF/GenotypesToBeKeptAfterSelection/ListASCacMad.rds")

# How many genotypes?
length(geno.names.sub)
```


> Load and prepare new genomic data

```{r GenomicNewDataMungingCacMad,eval=F}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

rm(geno_names)

# Select only genotypes which has at least one survivor
geno <- geno %>% dplyr::select(all_of(geno.names.sub))

geno <-  as_tibble(t(geno), rownames = "rownames") %>% 
  mutate(rownames=str_sub(rownames,1,3)) %>% 
  dplyr::rename(prov = rownames) %>% 
  group_by(prov) %>% 
  summarise_all(~sum(., na.rm = TRUE)/(n()*2))

saveRDS(geno,file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacMad.rds")
```

```{r LoadNewGenoPreparedCacMad,echo=F}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacMad.rds")
```

```{r RmMinorAlleleFrequenciesCacMad}
vec <- apply(geno[,-1],2,function(x) length(unique(x)))
vecsup <- vec[vec>5]
snps <- names(vecsup)
length(vecsup) # Number of SNPs polymorphic in > 5 populations
ncol(geno[,-1]) - length(vecsup) # Number of SNPs polymorphic in less than or equal to 5 populations
genoMAF <- geno %>% dplyr::select(contains(c("prov",snps)))
```

## Set 5

### Without altitude

#### Current climate 

```{r VarSet5AfterSelectionCacMad}
select.var <- select.var5
model.name <- "gfSet5AfterSelectionCacMad"
stack.name <- "StackSoilClimSet5"
```

```{r GFSet5AfterSelectionCacMad, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r GFSet5AfterSelectionCacMadMAF, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,genoMAF,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,"MAF.rds"))
```


```{r LoadGFSet5AfterSelectionCacMad, echo=F}
# Load model with all SNPs
# gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))

# Load models in which SNPs that were polymorphic in fewer than five of the 34 populations were removed to ensure robust regression 
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,"MAF.rds"))
```

```{r PlotGFSet5AfterSelectionCacMad, fig.height=5,fig.width=8}
plot(gf, plot.type="Overall.Importance")
#plot(gf, plot.type="Split.Density")
plot(gf, plot.type="Cumulative.Importance",
     imp.vars=c("bio13","bio14"),
     plot.args=list(show.species=FALSE,show.overall=TRUE))
#plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet5AfterSelectionCacMad, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Future climate (2041-2060) - GCM BCC-CSM2-MR (SSP245)

```{r MappingOutputsSet5FutClimAfterSelectionCacMad, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP245/",stack.name,"_BCCCSM2MR.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
predFut <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

> Genomic offset

```{r GenomicOffsetSet5AfterSelectionCacMad,fig.height=6,fig.width=8}
stackall <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/",stack.name,"ResWorldClim.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCurResWorldClim <- predict(gf, rasValue[,-1]) # remove cell column before transforming


# calculate euclidean distance between current and future genetic spaces  
genOffAScacmad <- sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2)


# assign values to raster - can be tricky if current/future climate
# rasters are not identical in terms of # cells, extent, etc.
values <- raster::extract(stackall, shp,cellnumbers=T)

rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- genOffAScacmad
plot(rast.go)
```


#### Future climate (2041-2060) - All GCMs (SSP370)


```{r Set5AfterSelectionCacMadFutClimAllGCMsCalculateGoSSP370}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP370/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5AfterSelectionCacMadFutClimAllGCMsPlotsSSP370, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Keeping mean and SD for futher analyses
dfGOallGCMs <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanASmadcac=mean,SdASmadcac=sd)
DFtot <- bind_cols(DFtot,dfGOallGCMs)
```


```{r PlotGOSet5AfterSelectionCacMadFutClimAllGCMsSSP370,fig.height=6,fig.width=8}
rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- dfGOallGCMs$MeanASmadcac
plot(rast.go)
```


#### Future climate (2041-2060) - All GCMs (SSP585)


```{r Set5AfterSelectionCacMadFutClimAllGCMsCalculateGoSSP585}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP585/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5AfterSelectionCacMadFutClimAllGCMsPlotsSSP585, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Keeping mean and SD for futher analyses
dfGOallGCMs <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanASmadcac=mean,SdASmadcac=sd)
DFtotssp585 <- bind_cols(DFtotssp585,dfGOallGCMs)
```

```{r PlotGOSet5AfterSelectionCacMadFutClimAllGCMsSSP585,fig.height=6,fig.width=8}
rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- dfGOallGCMs$MeanASmadcac
plot(rast.go)
```


# AFTER SELECTION in Caceres

## Loading new genotypic frequencies

> Extracting the genotype names to be selected 

```{r ExtractGenotypeNamesCacOnly}
geno.names.sub <- readRDS(file="../../data/PreparedDFforGDMandGF/GenotypesToBeKeptAfterSelection/ListASCacOnly.rds")

# How many genotypes?
length(geno.names.sub)
```




> Load and prepare new genomic data

```{r GenomicNewDataMungingCacOnly, eval=F}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

rm(geno_names)

# Select only genotypes which has at least one survivor
geno <- geno %>% dplyr::select(all_of(geno.names.sub))

geno <-  as_tibble(t(geno), rownames = "rownames") %>% 
  mutate(rownames=str_sub(rownames,1,3)) %>% 
  dplyr::rename(prov = rownames) %>% 
  group_by(prov) %>% 
  summarise_all(~sum(., na.rm = TRUE)/(n()*2))

saveRDS(geno,file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacOnly.rds")
```

```{r LoadNewGenoPreparedCacOnly,echo=F}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacOnly.rds")
```

```{r RmMinorAlleleFrequenciesCacOnly}
vec <- apply(geno[,-1],2,function(x) length(unique(x)))
vecsup <- vec[vec>5]
snps <- names(vecsup)
length(vecsup) # Number of SNPs polymorphic in > 5 populations
ncol(geno[,-1]) - length(vecsup) # Number of SNPs polymorphic in less than or equal to 5 populations
genoMAF <- geno %>% dplyr::select(contains(c("prov",snps)))
```

## Set 5

### Without altitude

#### Current climate 

```{r VarSet5AfterSelectionCacOnly}
select.var <- select.var5
model.name <- "gfSet5AfterSelectionCacOnly"
stack.name <- "StackSoilClimSet5"
```

```{r GFSet5AfterSelectionCacOnly, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,geno,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,".rds"))
```

```{r GFSet5AfterSelectionCacOnlyMAF, eval=F}
subdata <- data[,c("prov",select.var)]
colnames(subdata) <- c("prov",paste0(str_sub(c(select.var),0,-6)))

df <- dplyr::inner_join(mem,subdata,by="prov")
df <- inner_join(df,genoMAF,by="prov")
df[1:10,1:20]


# read in data file with minor allele freqs & env/space variables
envGF <- df %>% dplyr::select(-contains(c("longitude","latitude","prov","SNP"))) # get climate & MEM variables
envGF[1:10,]
maxLevel <- log2(0.368*nrow(envGF)/2) #account for correlations, see ?gradientForest 

# build individual SNP datasets
SNPs <- df %>% dplyr::select(contains("SNP")) # SNPs
SNPs[1:10,1:10]

# Fit gf models for reference SNPs 
gf <- gradientForest(cbind(envGF, SNPs), predictor.vars=colnames(envGF),
                        response.vars=colnames(SNPs), ntree=500, 
                        maxLevel=maxLevel, trace=T, corr.threshold=0.50)
saveRDS(gf,file=paste0("../../outputs/GF/models/",model.name,"MAF.rds"))
```

```{r LoadGFSet5AfterSelectionCacOnly, echo=F}
# Load model with all SNPs
# gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,".rds"))

# Load models in which SNPs that were polymorphic in fewer than five of the 34 populations were removed to ensure robust regression 
gf <- readRDS(file=paste0("../../outputs/GF/models/",model.name,"MAF.rds"))
```


Lots of warnings: "The response has five or fewer unique values.  Are you sure you want to do regression?"
Some info here: https://nickfountainjones.wordpress.com/tag/r/


```{r PlotGFSet5AfterSelectionCacOnly, fig.height=5,fig.width=8}
plot(gf, plot.type="Overall.Importance")
#plot(gf, plot.type="Split.Density")
plot(gf, plot.type="Cumulative.Importance",
     imp.vars=c("bio13","bio14"),
     plot.args=list(show.species=FALSE,show.overall=TRUE))
#plot(gf, plot.type="Performance")
```

```{r MappingOutputsSet5AfterSelectionCacOnly, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCur <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(projCur, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

#### Future climate (2041-2060) - GCM BCC-CSM2-MR (SSP245)

```{r MappingOutputsSet5FutClimAfterSelectionCacOnly, fig.height=8,fig.width=10}
stackall <- stack(paste0("../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP245/",stack.name,"_BCCCSM2MR.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
predFut <- predict(gf, rasValue[,-1]) # remove cell column before transforming

# ppcatoraster by hand
pca <- prcomp(predFut, center=TRUE, scale.=FALSE)

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]
mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 3, b = 2)
# plotRGB(outRast, r = 3, g = 1, b = 2)
```

> Genomic offset

```{r GenomicOffsetSet5AfterSelectionCacOnly}
stackall <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/",stack.name,"ResWorldClim.grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

# transform env using gf models, see ?predict.gradientForest
projCurResWorldClim <- predict(gf, rasValue[,-1]) # remove cell column before transforming


# calculate euclidean distance between current and future genetic spaces  
genOffAScac <- sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
                    +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
                    +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2)


# assign values to raster - can be tricky if current/future climate
# rasters are not identical in terms of # cells, extent, etc.
values <- raster::extract(stackall, shp,cellnumbers=T)

rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- genOffAScac
plot(rast.go)
```
  
```{r ComparingBeforeAndAfterSelectionSet5CacOnly,fig.height=6,fig.width=8}
GO <- data.frame(BS=genOffBS,AS=genOffAScacmad, AScac=genOffAScac)
GO <- GO %>%  pivot_longer(cols=everything(),names_to="subset",values_to="go")
ggplot(GO, aes(x=go,color=subset)) + 
  geom_density(size=1.5) +
  theme_bw() + 
  xlab("Genomic offset") +
  scale_color_discrete(name = "Subset of\n genotypes", labels = c("After selection in Madrid and Caceres","After selection in Caceres","Before Selection"))


ggplot(GO, aes(x=subset, y=go, fill=subset)) + 
  geom_boxplot(alpha=0.6) + 
  theme_bw() +
  scale_fill_discrete(name = "Subset of\n genotypes", labels = c("After selection in Madrid and Caceres","After selection in Caceres","Before Selection")) +
  ylab("Genomic offset") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```


#### Future climate (2041-2060) - All GCMs (SSP370)


```{r Set5AfterSelectionCacOnlyFutClimAllGCMsCalculateGoSSP370}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP370/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5AfterSelectionCacOnlyFutClimAllGCMsPlotsSSP370, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Comparing with BeforeSelection and AfterSelectionCacMad
dfGOallGCMs <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanAScac=mean,SdAScac=sd)
DFtot <- bind_cols(DFtot,dfGOallGCMs)

DFtot %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=go,color=subset)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")  +
    scale_color_discrete(name = "Subset of\n genotypes", labels = c("After selection in Caceres",
                                                                    "After selection in Madrid and Caceres",
                                                                    "Before Selection"))
DFtot %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=subset, y=go, fill=subset)) + 
    geom_boxplot(alpha=0.6) + 
    theme_bw() +
    scale_fill_discrete(name = "Subset of\n genotypes",
                      labels = c("After selection in Caceres",
                                 "After selection in Madrid and Caceres",
                                 "Before Selection")) +
    ylab("Genomic offset") +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

To show se instead of sd in the barplots: https://stackoverflow.com/questions/25999677/how-to-plot-mean-and-standard-error-in-boxplot-in-r


```{r PlotGOSet5AfterSelectionCacOnlyFutClimAllGCMsSSP370,fig.height=6,fig.width=8}
rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- dfGOallGCMs$MeanAScac
plot(rast.go)
```



#### Future climate (2041-2060) - All GCMs (SSP585)


```{r Set5AfterSelectionCacOnlyFutClimAllGCMsCalculateGoSSP585}
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP585/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRange)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```

```{r Set5AfterSelectionCacOnlyFutClimAllGCMsPlotsSSP585, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Comparing with BeforeSelection and AfterSelectionCacMad
dfGOallGCMs <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanAScac=mean,SdAScac=sd)
DFtotssp585 <- bind_cols(DFtotssp585,dfGOallGCMs)

DFtotssp585 %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=go,color=subset)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")#  +
    # scale_color_discrete(name = "Subset of\n genotypes", labels = c("After selection in Caceres",
    #                                                                 "After selection in Madrid and Caceres",
    #                                                                 "Before Selection"))
DFtotssp585 %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=subset, y=go, fill=subset)) + 
    geom_boxplot(alpha=0.6) + 
    theme_bw() # +
    # scale_fill_discrete(name = "Subset of\n genotypes",
    #                   labels = c("After selection in Caceres",
    #                              "After selection in Madrid and Caceres",
    #                              "Before Selection")) +
    ylab("Genomic offset") +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

```{r PlotGOSet5AfterSelectionCacOnlyFutClimAllGCMsSSP585,fig.height=6,fig.width=8}
rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- dfGOallGCMs$MeanAScac
plot(rast.go)
```


# Map diff b/w turnover in genetic composition BS and AS

[Fitzpatrick and Keller (2014)](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12376) :"To estimate the congruence (or lack thereof) between the mapped genetic patterns for reference SNPs and the four candidate SNP data sets, we performed a Procrustes superimposition on the resulting PCA ordinations, where the matrices were rotated to minimise the sum of square of the distances between the sites in genetic space (Peres‐Neto & Jackson 2001). The Procrustes residuals, which in this case measure the absolute distance between sites in genetic space and the rotated ordination space, were mapped to provide a location‐specific measure of the difference in genetic composition patterns between reference and the four sets of candidate SNPs. For all visualisations, we constrained predictions to within the geographic range of balsam poplar as defined by Little (1971)."

**So here we compare the genetic patterns before selection (BS), after selection in Madrid and Caceres (ASMadCac) and after selection in Caceres (ASCacOnly).**


```{r MapGeneticDiffCurrentClimBSandAS}
stack.name <- "StackSoilClimSet5"

# Model fitted on frequencies before selection
gfBS <- readRDS(file=paste0("../../outputs/GF/models/gfSet5MAF.rds"))

# Model fitted on frequencies after selection in Madrid and Caceres
gfASCacMad <- readRDS(file=paste0("../../outputs/GF/models/gfSet5AfterSelectionCacMad.rds"))

# Model fitted on frequencies after selection in Caceres
gfASCacOnly <- readRDS(file=paste0("../../outputs/GF/models/gfSet5AfterSelectionCacOnly.rds"))

stackall <- stack(paste0("../../data/StacksEnvVars/",stack.name,".grd"))

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)
  
predFutBS <- predict(gfBS, rasValue[,-1])
predFutASCacMad <- predict(gfASCacMad, rasValue[,-1])
predFutASCacOnly <- predict(gfASCacOnly, rasValue[,-1])

PCA.BS <- prcomp(predFutBS, center=TRUE, scale.=FALSE)
PCA.ASCacMad <- prcomp(predFutASCacMad, center=TRUE, scale.=FALSE)
PCA.ASCacOnly <- prcomp(predFutASCacOnly, center=TRUE, scale.=FALSE)

resid.diffProcrust.BS.ASCacMad <- residuals(procrustes(PCA.BS, PCA.ASCacMad, scale=TRUE, symmetrical=FALSE))
resid.diffProcrust.BS.ASCacOnly <- residuals(procrustes(PCA.BS, PCA.ASCacOnly, scale=TRUE, symmetrical=FALSE))
resid.diffProcrust.ASCacMad.ASCacOnly <- residuals(procrustes(PCA.ASCacMad, PCA.ASCacOnly, scale=TRUE, symmetrical=FALSE))

rast.Procrust.BS.ASCacMad <- stackall[[1]]
rast.Procrust.BS.ASCacOnly <- stackall[[1]]
rast.Procrust.ASCacMad.ASCacOnly <- stackall[[1]]

rast.Procrust.BS.ASCacMad[rasValue$cell] <- resid.diffProcrust.BS.ASCacMad
rast.Procrust.BS.ASCacOnly[rasValue$cell] <- resid.diffProcrust.BS.ASCacOnly
rast.Procrust.ASCacMad.ASCacOnly[rasValue$cell] <- resid.diffProcrust.ASCacMad.ASCacOnly
```

To plot the **difference between turnover in genetic composition** before and after the selection events based on **Procrustes residuals**, the distances are **scaled to the maximum distance** found between the three comparisons (BS vs ASMadCac, BS vs ASMadOnly, ASMadCac vs ASMadOnly). In [Fitzpatrick & Keller (2014)](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.12376): "The (c) difference between turnover in genetic composition of reference SNPs and GI5 is based on Procrustes residuals, with distances scaled to the maximum distance found in any comparison between reference and the four candidate SNP data sets from both GF and GDM".
 
```{r MapDiffBSandAS, fig.height=8,fig.width=10, eval=F,echo=F}
# If we want to plot the non standardized procrutes residuals
plot(rast.Procrust.BS.ASCacMad,box = FALSE,
     axes = FALSE,
     alpha=0.8,
      col=colorRampPalette(c("blue","yellow","red"))(255),
     zlim=c(0,0.005))

plot(rast.Procrust.BS.ASCacOnly,box = FALSE,
     axes = FALSE,
     alpha=0.8,
      col=colorRampPalette(c("blue","yellow","red"))(255),
     zlim=c(0,0.005))

plot(rast.Procrust.ASCacMad.ASCacOnly,box = FALSE,
     axes = FALSE,
     alpha=0.8,
      col=colorRampPalette(c("blue","yellow","red"))(255),
     zlim=c(0,0.005))
```

```{r MapDiffBSandASStandardized, fig.height=8,fig.width=10}
max.resid <- max(max(resid.diffProcrust.BS.ASCacMad), 
    max(resid.diffProcrust.BS.ASCacOnly),
    max(resid.diffProcrust.ASCacMad.ASCacOnly))
max.resid 

rast.Procrust.BS.ASCacMad[rasValue$cell] <- resid.diffProcrust.BS.ASCacMad / max.resid
rast.Procrust.BS.ASCacOnly[rasValue$cell] <- resid.diffProcrust.BS.ASCacOnly / max.resid
rast.Procrust.ASCacMad.ASCacOnly[rasValue$cell] <- resid.diffProcrust.ASCacMad.ASCacOnly / max.resid

plot(rast.Procrust.BS.ASCacMad,box = FALSE,
     axes = FALSE,
     alpha=0.8,
     zlim=c(0,1),
     main="Before selection VS After selection in Madrid and Caceres",
     col=colorRampPalette(c("blue","yellow","red"))(255))

plot(rast.Procrust.BS.ASCacOnly,box = FALSE,
     axes = FALSE,
     alpha=0.8,
     zlim=c(0,1),
     main="Before selection VS After selection in Caceres",
     col=colorRampPalette(c("blue","yellow","red"))(255))

plot(rast.Procrust.ASCacMad.ASCacOnly,box = FALSE,
     axes = FALSE,
     alpha=0.8,
     zlim=c(0,1),
     col=colorRampPalette(c("blue","yellow","red"))(255),
     main="After selection in Madrid and Caceres VS After selection in Caceres")
```


# Comparing SNP frequencies

```{r}
geno <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequencies.rds")
vec <- apply(geno[,-1],2,function(x) length(unique(x)))
vecsup <- vec[vec>5]
snps <- names(vecsup)
length(vecsup) # Number of SNPs polymorphic in > 5 populations
ncol(geno[,-1]) - length(vecsup) # Number of SNPs polymorphic in less than or equal to 5 populations
genoBS <- geno %>% dplyr::select(contains(c("prov",snps)))
```

```{r}
genoAS <- readRDS(file="../../data/PreparedDFforGDMandGF/GF/GenoDataWithFrequenciesAfterSelectionCacMad.rds")

# In fact, I don't think I should remove the alleles with less than 5 polymorphic populations in this second matrix as this matrix will not be used in the GF in fact.. 


# vec <- apply(geno[,-1],2,function(x) length(unique(x)))
# vecsup <- vec[vec>5]
# snps <- names(vecsup)
# length(vecsup) # Number of SNPs polymorphic in > 5 populations
# ncol(geno[,-1]) - length(vecsup) # Number of SNPs polymorphic in less than or equal to 5 populations
# genoAS <- geno %>% dplyr::select(contains(c("prov",snps)))

genoAS <- genoAS[,!(names(genoAS) %in% setdiff(names(genoAS),names(genoBS)))]
#genoBS <- genoBS[,!(names(genoBS) %in% setdiff(names(genoBS),names(genoAS)))]

```

```{r}
diff <- abs(genoBS[,-1] - genoAS[,-1])
meancol <- apply(diff,2,mean)
plot(sort(meancol))
sumcol <- apply(diff,2,sum)
plot(sort(sumcol))
sum.diff <- names(which(sumcol>0.6))

# R2 of allele in gf
plot(sort(gf$result))
res.gf <- names(which(gf$result>0.6))

intersect(sum.diff,res.gf)
gf$result[names(gf$result)=="SNP_1131"]
sumcol[names(sumcol)=="SNP_1131"]

most_important <- names(importance(gf))[1:25]
```

```{r fig.height=20, fig.width=20}
# plot(gf, plot.type = "C", imp.vars = most_important,
#      show.overall = F, legend = T, leg.posn = "topleft",
#      leg.nspecies = 5, cex.lab = 0.7, cex.legend = 0.4,
#      cex.axis = 0.6, line.ylab = 0.9, par.args = list(mgp = c(1.5,0.5, 0), 
#                                                       mar = c(2.5, 1, 0.1, 0.5), 
#                                                       omi = c(0,0.3, 0, 0)))
plot(gf, plot.type="Cumulative.Importance",
     imp.vars=c("bio13","bio14","bio5","bio5"),
     plot.args=list(show.species=TRUE,show.overall=FALSE))
```

`r knitr::opts_chunk$set(eval = F)`
---
title: "GDM"
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
---


<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 5,fig.height = 4,cache=TRUE)
options(width = 300)
library(knitr)
library(hierfstat)
library(reshape2)
library(ggbiplot)
library(gdm)
#library(cowplot)
#library(ggplot2)
#library(ggpubr)
#library(stringi)
library(beepr)
library(dplyr)
#library(devtools)
#library(xtable)
library(tidyverse)
#library(tibble)
library(raster)
library(sgdm)
```

Mayeb some interesting information here: 

  - https://thierrygosselin.github.io/assigner/articles/web_only/fst_comparisons.html
  - some useful code here: https://github.com/cran/gdm/blob/master/R/GDM_Table_Funcs.R
  - not sure it will be useful X) https://popgen.nescent.org/DifferentiationSNP.html
  - hierfstats package use https://www.sciencedirect.com/science/article/pii/S1567134807001037?via%3Dihub
  - help page gdm https://cran.r-project.org/web/packages/gdm/gdm.pdf#Rfn.formatsitepair
  - http://www.mountainmanmaier.com/software/pop_genom/
  
  
  

<!-- Functions & Options used -->

```{r FuntionsOptionsUsed,echo=F}
source("../../scripts/Functions/corpmat.R")
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))

# Gray scale
grayscale_colors <- gray.colors(100,            # number of different color levels
                                start = 0.0,    # how black (0) to go
                                end = 1.0,      # how white (1) to go
                                gamma = 2.2,    # correction between how a digital
                                # camera sees the world and how human eyes see it
                                alpha = NULL)
```

```{r Functions}
GOAcrossRangeWithGDM <- function(x){
  
  rast.pred <- predict.gdm(model, stack.cur.clim,time=TRUE, predRasts=x) 
  rasValue <- raster::extract(rast.pred, shp,cellnumbers=T)
  rasValue <- as.data.frame(rasValue)
  rasValue <- na.omit(rasValue)
  return(rasValue$value)

}
```


# DATA

## Calculating the Fst matrix

To calculate the Fst matrix, we use Weir and Cockerham method. 


```{r  LoadFilesAndFormat}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)
str(geno[,1:20])
dim(geno) # SNPs in rows, genotypes in columns

# In this file, SNPs have their names, but not the genotypes.
head(geno[,1:10])

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

rm(geno_names)

head(geno[,1:10])
dim(geno)
unique(unlist(geno))
```

<!-- I followed the example in the package 'hierfstats' to format the dataset. Here is the exemple of the package hierfstats: -->

```{r HierfstatsExample, eval=F,echo=F}
data(gtrunchier)
head(gtrunchier)
pairwise.WCfst(gtrunchier[,-2],diploid=TRUE)
```

```{r  PrepareData}
geno[geno ==1] <- 12
geno[geno ==2] <- 22
geno[geno ==0] <- 11
geno <- t(geno) # SNps in column and genotypes in row
geno <- as.data.frame(geno)
geno$prov <- substr(row.names(geno), 0, 3)
geno <- geno %>% dplyr::select(prov, everything())
geno[1:10,1:10]
dim(geno)
```


### Before selection

```{r ComputeFstMatrixBS}
# fst <- pairwise.WCfst(geno,diploid=TRUE)
# saveRDS(fst,file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165SnpsRawBS.rds")
fst <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165SnpsRawBS.rds")
```

4 Fst values have very very small negative values. We set them to 0.

```{r NegValuestoZeroFstMatrix}
fst[which(fst <0)]
fst[which(fst <0)] <- 0
round(fst,2)
# saveRDS(fst,file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsBS.rds")
```


### After selection in Madrid and Caceres

```{r ExtractGenotypeNamesCacMad, eval=F}
geno.names.sub <- readRDS(file="../../data/PreparedDFforGDMandGF/GenotypesToBeKeptAfterSelection/ListASCacMad.rds")

# How many genotypes?
length(geno.names.sub)

# Select only genotypes which has at least one survivor
geno <- geno[geno.names.sub,]
dim(geno)

fst <- pairwise.WCfst(geno,diploid=TRUE)
saveRDS(fst,file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165SnpsRawASCacMad.rds")
```


4 Fst values have very very small negative values. We set them to 0.

```{r NegValuestoZeroFstMatrixCacMad}
fst <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165SnpsRawASCacMad.rds")
fst[which(fst <0)]
fst[which(fst <0)] <- 0
round(fst,2)
# saveRDS(fst,file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsASCacMad.rds")
```



### After selection in Caceres

```{r ExtractGenotypeNamesCacOnly, eval=F}
geno.names.sub <- readRDS(file="../../data/PreparedDFforGDMandGF/GenotypesToBeKeptAfterSelection/ListASCacOnly.rds")

# How many genotypes?
length(geno.names.sub)

# Select only genotypes which has at least one survivor
geno <- geno[geno.names.sub,]
dim(geno)
fst <- pairwise.WCfst(geno,diploid=TRUE)
saveRDS(fst,file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165SnpsRawASCacOnly.rds")
```

```{r NegValuestoZeroFstMatrixCacOnly}
fst <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165SnpsRawASCacOnly.rds")
fst[which(fst <0)]
fst[which(fst <0)] <- 0
round(fst,2)
heatmap(fst)
# saveRDS(fst,file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsASCacOnly.rds")
```


16 Fst values have very very small negative values. We set them to 0.






## Climatic and soil values for each provenance

This corresponds to the mean climatic values between 1901 and 2009 (that I have already calculated in the previous paper).

```{r LoadEnvData}
data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
data <- data %>% select(contains("prov"))
data <- unique(data)
data <- data[!(data$prov=="ROD"),]
data
```

```{r VizualizeEnvData,fig.height=13,fig.width=13}
cor <- data %>%  select(contains("_prov"),-contains("sub")) %>% cor()
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=23, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", number.cex =0.8,tl.cex = 0.8,
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- data %>%  select(contains("_prov"),-contains("sub")) %>%  prcomp(center = TRUE,scale. = TRUE)
ggbiplot(pca,varname.size =4) +  ylim(-4.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
```

Comment:

- `pet.max_prov` and `bio2_prov` are highly positively correlated with the altitude, and `bio6_prov` and `ppet.min_prov` are highly negatively correlated with the altitude. 

- Importantly, the altitude is highly correlated (0.86) to latitude...



### Set 1 

First set of climatic, soil and altitude variables

```{r SelectEnvDataSet1,fig.height=5,fig.width=5}
# Select env variables
select.var <- c(paste0("bio",c(1,12,14,5),"_prov"),"sand_top_prov","depth_roots_prov")
cor <- cor(data[,c(select.var,"altitude_prov")])

# matrix of the p-value of the correlation
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=45, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", 
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- prcomp(data[,grep("_prov",c(select.var,"altitude_prov"),value = T)], center = TRUE,scale. = TRUE)
ggbiplot(pca,varname.size =4) +  ylim(-4.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
```

### Set 2

Second set of climatic, soil and altitude variables

```{r SelectEnvDataSet2,fig.height=5,fig.width=5}
select.var2 <- c("bio1_prov","bio12_prov","bio6_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")
cor <- cor(data[,c(select.var2,"altitude_prov")])

# matrix of the p-value of the correlation
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=45, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", 
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- prcomp(data[,c(select.var2,"altitude_prov")], center = TRUE,scale. = TRUE)

ggbiplot(pca,varname.size =4) +  ylim(-4.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
```


### Set 3

Third set of climatic, soil and altitude variables

```{r SelectEnvDataSet3,fig.height=5,fig.width=5}
select.var3 <- c("bio1_prov","bio14_prov","ppet.mean_prov","sand_top_prov","depth_roots_prov")
cor <- cor(data[,c(select.var3,"altitude_prov")])

# matrix of the p-value of the correlation
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=45, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", 
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- prcomp(data[,c(select.var3,"altitude_prov")], center = TRUE,scale. = TRUE)

ggbiplot(pca,varname.size =4) +  ylim(-4.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
```



### Set 4

Fourth set of climatic, soil and altitude variables. Same of set 3, but without altitude.

```{r SelectEnvDataSet4,fig.height=5,fig.width=5}
select.var4 <- c("bio1_prov","bio14_prov","ppet.mean_prov","ppet.min_prov","sand_top_prov","depth_roots_prov")
cor <- cor(data[,c(select.var4,"altitude_prov")])

# matrix of the p-value of the correlation
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=45, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", 
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- prcomp(data[,c(select.var4,"altitude_prov")], center = TRUE,scale. = TRUE)

ggbiplot(pca,varname.size =4) +  ylim(-4.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
```

### Set 5

Fith set of climatic and soil variables. 
Only variables representing episodiac climatic conditions:

  - 'bio5': max temperature of the warmest month (°C)
  - 'bio6': min temperature of the coldest month (°C)
  - 'bio13': precipitation of the wettest month (mm)
  - 'bio14': precipitation of the driest month (mm)

```{r SelectEnvDataSet5,fig.height=5,fig.width=5}
select.var5 <- c("bio13_prov","bio14_prov","bio5_prov","bio6_prov","sand_top_prov","depth_roots_prov")
cor <- cor(data[,c(select.var5,"altitude_prov")])

# matrix of the p-value of the correlation
p.mat <- corpmat(cor)

corrplot::corrplot(cor, method="color", col=col(200),  
                   type="upper", order="hclust", 
                   addCoef.col = "black", # Add coefficient of correlation
                   tl.col="black", tl.srt=45, #Text label color and rotation
                   # Combine with significance
                   p.mat = p.mat, sig.level = 0.01, insig = "blank", 
                   # hide correlation coefficient on the principal diagonal
                   diag=FALSE)

pca <- prcomp(data[,c(select.var5,"altitude_prov")], center = TRUE,scale. = TRUE)

ggbiplot(pca,varname.size =4) +  ylim(-4.5, 2.5) +    xlim(-3, 3) +  
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(size=12))
```


## Climatic, altitude and soil rasters

```{r MaritimePineDistriMask}
# Maritime pine distribution from EUFORGEN (shapefile)
shp  <- shapefile('../../../../Pinpin_Clonapin/maps/pinus_pinaster_distribution/Pinus_pinaster_EUFORGEN.shp')
```


```{r LoadRastersAndShapefile,eval=F,echo=F}
# Climatic rasters
grids <- list.files("../../data/climate/Tiff_1901_2009/" , pattern = "*1901-2009_with_34_sampling_points.tif$")
grids <- grids[grepl("bio5_|bio14_|bio12_|bio1_",grids)==T]
grids <- c(grids[[1]],grids[[4]],grids[[2]],grids[[3]])
rast <- raster::stack(paste0("../../data/climate/Tiff_1901_2009/", grids))
names(rast) <- c("bio1","bio5","bio12","bio14")
rast <- mask(rast,shp, updatevalue=NA)


# SRTM altitude raster
rast.alt <- raster("../../data/Topography/SrtmWGS84/MosaicTif/srtm_mosaic.tif")
rast.alt <- crop(rast.alt,extent(rast)) # attribute the extent of climatic raster to altitude rasters
rast.alt <- raster::resample(rast.alt,rast) # same number of cells between the altitude and climatic rasters
rast.alt <- mask(rast.alt,shp,updatevalue=NA) # keep only cells within maritime pine distribution 

# Soil rasters
stack.soil <- stack("../../data/soil/STU_EU_DEPTH_ROOTS_WGS84.tif","../../data/soil/STU_EU_T_SAND_WGS84.tif")
names(stack.soil) <- c("depth_roots","sand_top")
stack.soil <- crop(stack.soil,extent(rast)) # attribute the extent of climatic raster to soil raster
stack.soil <- raster::resample(stack.soil,rast) # same number of cells between the soil and climatic rasters
stack.soil <- mask(stack.soil,shp,updatevalue=NA) # keep only cells within maritime pine distribution 
```


## Hillshade (background)

```{r MapBackground}
# fond de carte
# https://land.copernicus.eu/imagery-in-situ/eu-dem/eu-dem-v1-0-and-derived-products/slope?tab=download
# Need to create an account

# I took the hillsahede map from here:
# https://www.eea.europa.eu/data-and-maps/data/digital-elevation-model-of-europe

background <- raster("../../data/maps/EuropeanData/hillshade1x1.tif")
plot(background,col=grayscale_colors, axes=FALSE,legend=F)
background <- projectRaster(background, crs="+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
background
e <- extent(-10, 14, 31, 46)
background <- crop(background, e)

# text(9,32,"Potentiels refuges climatiques\ndes pois chiches\n lors du réchauffement climatique")
```


# BEFORE SELECTION

## Fst matrix

```{r LoadFstMatrix}
fst <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsBS.rds")
fst <- as.data.frame(fst) 
fst <- fst %>%  tibble::rownames_to_column("prov") # The distance matrix must have as the first column the names of the provenances
mean(unlist(fst[,-1]),na.rm=T)
range(unlist(fst[,-1]),na.rm=T)
sd(unlist(fst[,-1]),na.rm=T)
```

We run the GDM directly with the Fst matrix, but we can't use rasters with fst matrix in 'formatsitepair' function.

bioData = site-by-site distance (dissimilarity) matrix; bioFormat = 3: is used when a site-by-site distance (dissimilarity) matrix has already been created for the biological response (e.g., Fst for genetic data). The distance matrix must have as the first column the names of the sites (therefore the matrix will not be square). The column of site names should have the same name as the siteColumn argument. Only the lower half (triangle) of the matrix is needed to create the site-pair output table, but this function automatically removes the upper half if present. This is the only bioFormat in which the environmental data CANNOT be provided as a raster object.


## GDM analysis

Options to discuss with Santi:

- Do we include the **geographic distance between provenances** as a model term? geo=T

- Do we include **altitude** as a model term?


> Comment 

When trying to run GDM without altitude as parameter but with geo=T, it doesn't work. Warning message: "The algorithm was unable to fit a model to your data. The sum of the spline coefficients = 0 and deviance explained = NULL. Returning NULL object.".

### Set 1

#### Accounting for geographic distance (with altitude)

```{r FormatDataGeoDistAlt}
subdata <- data[,c("prov","latitude_prov","longitude_prov","altitude_prov",select.var)]
colnames(subdata) <- c("prov","longitude","latitude","altitude",paste0(str_sub(select.var,0,-6)))

gdmTab_alt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_alt)
```

```{r RunningGDMGeoDistAlt,fig.height=7,fig.width=7}
gdm.1 <- gdm(gdmTab_alt, geo=T)
gdm.1

# Deviance explained
gdm.1$explained


# Leave-one out cross validation
sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "r2",geo=T) # R2
sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_alt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_alt,nfolds = 2,performance = "r2",geo=T)


par(mfrow=c(2,2))
# plot(gdm.1) # automatically return all graphs (but with default legends)
gdm.1.splineDat <- isplineExtract(gdm.1)
# str(gdm.1.splineDat)
plot(gdm.1.splineDat$x[,"Geographic"], gdm.1.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)
gdm.1.pred <- predict.gdm(gdm.1, gdmTab_alt)
# head(gdm.1.pred)


plot(gdmTab_alt$distance, gdm.1.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))


plot(gdm.1.splineDat[[1]][,"bio1"], gdm.1.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Mean T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.1.splineDat[[1]][,"bio5"], gdm.1.splineDat[[2]][,"bio5"], type="l",lwd=3, xlab="Max T° of the warmest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.1.splineDat[[1]][,"bio12"], gdm.1.splineDat[[2]][,"bio12"], type="l",lwd=3, xlab="Annual precipitation (mm)", ylab="Partial Ecological Distance")
plot(gdm.1.splineDat[[1]][,"bio14"], gdm.1.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.1.splineDat[[1]][,"sand_top"], gdm.1.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.1.splineDat[[1]][,"depth_roots"], gdm.1.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
plot(gdm.1.splineDat[[1]][,"altitude"], gdm.1.splineDat[[2]][,"altitude"], type="l",lwd=3, xlab="Altitude", ylab="Partial Ecological Distance")
```


Only a small effect of the precipitation of the driest month. The other climatic variables have no effect. Stronger effect of the altitude and the geographic distance.


```{r VizualizeGDM1, fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackAltSoilClimSet1.grd")
stackall

rastTrans <- gdm.transform(gdm.1, stackall)

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plotRGB(pcaRast, r=1, g=2, b=3)

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```

#### No accounting for geographic distance (with altitude)


```{r RunningGDMAlt,fig.height=7,fig.width=7}
gdm.2 <- gdm(gdmTab_alt, geo=F)
gdm.2

# Deviance explained
gdm.2$explained


# Leave-one out cross validation
sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "r2",geo=F) # R2
sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "rmse",geo=F) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_alt,nfolds = 17,performance = "r2",geo=F)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_alt,nfolds = 2,performance = "r2",geo=F)


par(mfrow=c(2,2))
# plot(gdm.1) # automatically return all graphs (but with default legends)
gdm.2.splineDat <- isplineExtract(gdm.2)

gdm.2.pred <- predict(gdm.2, gdmTab_alt)
plot(gdmTab_alt$distance, gdm.2.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))


plot(gdm.2.splineDat[[1]][,"bio1"], gdm.2.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Mean T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.2.splineDat[[1]][,"bio5"], gdm.2.splineDat[[2]][,"bio5"], type="l",lwd=3, xlab="Max T° of the warmest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.2.splineDat[[1]][,"bio12"], gdm.2.splineDat[[2]][,"bio12"], type="l",lwd=3, xlab="Annual precipitation (mm)", ylab="Partial Ecological Distance")
plot(gdm.2.splineDat[[1]][,"bio14"], gdm.2.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.2.splineDat[[1]][,"sand_top"], gdm.2.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.2.splineDat[[1]][,"depth_roots"], gdm.2.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
plot(gdm.2.splineDat[[1]][,"altitude"], gdm.2.splineDat[[2]][,"altitude"], type="l",lwd=3, xlab="Altitude", ylab="Partial Ecological Distance")
```


```{r VizualizeGDM2,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackAltSoilClimSet1.grd")
stackall

rastTrans <- gdm.transform(gdm.2, stackall)

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```


#### Accounting for geographic distance (without altitude)

```{r FormatDataGeoDist}
subdata <- data[,c("prov","latitude_prov","longitude_prov",select.var)]
colnames(subdata) <- c("prov","longitude","latitude",paste0(str_sub(select.var,0,-6)))

gdmTab_noalt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_noalt)
```

```{r RunningGDMGeoDist,fig.height=7,fig.width=7}
gdm.3 <- gdm(gdmTab_noalt, geo=T)
gdm.3

# Deviance explained
gdm.3$explained


# Leave-one out cross validation
# sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "r2",geo=T) # R2 # 
# Error message:  Returning NULL object.Error in UseMethod("predict") : 
  # pas de méthode pour 'predict' applicable pour un objet de classe "NULL"
# sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 2,performance = "r2",geo=T)


par(mfrow=c(2,2))
gdm.3.splineDat <- isplineExtract(gdm.3)

plot(gdm.3.splineDat$x[,"Geographic"], gdm.3.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)

gdm.3.pred <- predict.gdm(gdm.3, gdmTab_noalt) # HERE
plot(gdmTab_noalt$distance, gdm.3.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.3.splineDat[[1]][,"bio1"], gdm.3.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Mean T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.3.splineDat[[1]][,"bio5"], gdm.3.splineDat[[2]][,"bio5"], type="l",lwd=3, xlab="Max T° of the warmest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.3.splineDat[[1]][,"bio12"], gdm.3.splineDat[[2]][,"bio12"], type="l",lwd=3, xlab="Annual precipitation (mm)", ylab="Partial Ecological Distance")
plot(gdm.3.splineDat[[1]][,"bio14"], gdm.3.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.3.splineDat[[1]][,"sand_top"], gdm.3.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.3.splineDat[[1]][,"depth_roots"], gdm.3.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
```


Only a small effect of the precipitation of the driest month. The other climatic variables have no effect. Stronger effect of the altitude and the geographic distance.


```{r VizualizeGDM3,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackSoilClimSet1.grd")
stackall

rastTrans <- gdm.transform(gdm.3, stackall)

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```


#### No accounting for geographic distance (without altitude)

```{r RunningGDM,fig.height=7,fig.width=7}
gdm.4 <- gdm(gdmTab_noalt,geo=F)
gdm.4

gdm.4$explained

# Leave-one out cross validation
sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "r2",geo=F) # R2
sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "rmse",geo=F) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 17,performance = "r2",geo=F)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 2,performance = "r2",geo=F)


par(mfrow=c(2,2))
gdm.4.splineDat <- isplineExtract(gdm.4)
gdm.4.pred <- predict(gdm.4, gdmTab_noalt)
plot(gdmTab_noalt$distance, gdm.4.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.4.splineDat[[1]][,"bio1"], gdm.4.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Mean T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.4.splineDat[[1]][,"bio5"], gdm.4.splineDat[[2]][,"bio5"], type="l",lwd=3, xlab="Max T° of the warmest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.4.splineDat[[1]][,"bio12"], gdm.4.splineDat[[2]][,"bio12"], type="l",lwd=3, xlab="Annual precipitation (mm)", ylab="Partial Ecological Distance")
plot(gdm.4.splineDat[[1]][,"bio14"], gdm.4.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
```

Bad model. 



```{r VizualizeGDM4,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackSoilClimSet1.grd")
stackall

rastTrans <- gdm.transform(gdm.4, stackall)

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```


Here I kept the first way I used to vizualize the genomic composition. 

```{r VizualizeGDM4FirstMethod,fig.height=7,fig.width=10}
# Maritime pine distribution from EUFORGEN (shapefile)
shp  <- shapefile('../../../../Pinpin_Clonapin/maps/pinus_pinaster_distribution/Pinus_pinaster_EUFORGEN.shp')

# load climatic rasters
grids <- list.files("../../data/climate/Tiff_1901_2009/" , pattern = "*1901-2009_with_34_sampling_points.tif$")
grids <- grids[grepl("bio1_|bio14_|bio12_|bio5_",grids)==T]
climrast <- raster::stack(paste0("../../data/climate/Tiff_1901_2009/", grids))
names(climrast) <- c("bio1","bio12","bio14","bio5")


# load soil rasters
stack.soil <- stack("../../data/soil/STU_EU_T_SAND_WGS84.tif","../../data/soil/STU_EU_DEPTH_ROOTS_WGS84.tif")
names(stack.soil) <- c("sand_top","depth_roots")
stack.soil <- crop(stack.soil,extent(climrast)) # attribute the extent of climatic raster to soil raster
stack.soil <- raster::resample(stack.soil,climrast) # same number of cells between the soil and climatic rasters
stack.soil <- mask(stack.soil,shp,updatevalue=NA) # keep only cells within maritime pine distribution 

maskpinpin <- mask(climrast[[1]],shp, updatevalue=NA)

stackall <- stack(stack.soil,climrast)


#plot(rast)
rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

rastTrans <- gdm.transform(gdm.4, rasValue[,-1])

# ppcatoraster by hand
pca <- prcomp(rastTrans, center=TRUE, scale.=FALSE)
  
    ##assigns to colors, edit as needed to maximize color contrast, etc.
  a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
  r <- a1+a2; g <- -a2; b <- a3+a2-a1
  
  ##scales colors
  scalR <- (r-min(r))/(max(r)-min(r))*255
  scalG <- (g-min(g))/(max(g)-min(g))*255
  scalB <- (b-min(b))/(max(b)-min(b))*255
  
  ##assigns color to raster
  rast1 <- rast2 <- rast3 <- maskpinpin
  mapCells <- rasValue$cell
  rast1[mapCells] <- scalR
  rast2[mapCells] <- scalG
  rast3[mapCells] <- scalB
  ##stacks color rasters
  outRast <- stack(rast1, rast2, rast3)
  plotRGB(outRast, r = 1, g = 2, b = 3)
  
# 
#   plot(outRast,
#      col=grayscale_colors)

#writeRaster(outRast, "../../figs/refSNPs_map.tif", format="GTiff", overwrite=TRUE)
#rgb <- brick("../../figs/refSNPs_map.tif")
#writeRaster(outRast, filename="../../figs/multi.grd", bandorder='BIL', overwrite=TRUE)
```

### Set 2

#### Accounting for geographic distance (with altitude)

> Strongly correlated variables !! Maybe it's too correlated...

```{r FormatDataGeoDistAltSet2}
subdata <- data[,c("prov","latitude_prov","longitude_prov","altitude_prov",select.var2)]
colnames(subdata) <- c("prov","longitude","latitude","altitude",paste0(str_sub(select.var2,0,-6)))

gdmTab_alt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_alt)
```

```{r RunningGDMGeoDistAltSet2,fig.height=7,fig.width=7}
gdm.6 <- gdm(gdmTab_alt, geo=T)
gdm.6

# Deviance explained
gdm.6$explained


# Leave-one out cross validation
#sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "r2",geo=T) # R2
#sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
#sgdm::gdm.cv(gdmTab_alt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
#sgdm::gdm.cv(gdmTab_alt,nfolds = 2,performance = "r2",geo=T)


par(mfrow=c(2,2))
# plot(gdm.1) # automatically return all graphs (but with default legends)
gdm.6.splineDat <- isplineExtract(gdm.6)
# str(gdm.6.splineDat)
plot(gdm.6.splineDat$x[,"Geographic"], gdm.6.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)
gdm.6.pred <- predict.gdm(gdm.6, gdmTab_alt)
# head(gdm.6.pred)


plot(gdmTab_alt$distance, gdm.6.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.6.splineDat[[1]][,"bio12"], gdm.6.splineDat[[2]][,"bio12"], type="l",lwd=3, xlab="Annual precipitation (mm)", ylab="Partial Ecological Distance")
plot(gdm.6.splineDat[[1]][,"bio1"], gdm.6.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Annual T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.6.splineDat[[1]][,"ppet.min"], gdm.6.splineDat[[2]][,"ppet.min"], type="l",lwd=3, xlab="Minimum PPET", ylab="Partial Ecological Distance")
plot(gdm.6.splineDat[[1]][,"bio6"], gdm.6.splineDat[[2]][,"bio6"], type="l",lwd=3, xlab="Minimum T° of the coldest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.6.splineDat[[1]][,"sand_top"], gdm.6.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.6.splineDat[[1]][,"depth_roots"], gdm.6.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
plot(gdm.6.splineDat[[1]][,"altitude"], gdm.6.splineDat[[2]][,"altitude"], type="l",lwd=3, xlab="Altitude", ylab="Partial Ecological Distance")
```


```{r VizualizeGDM6, fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackAltSoilClimSet2.grd")

rastTrans <- gdm.transform(gdm.6, stackall)

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plotRGB(pcaRast, r=1, g=2, b=3)

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```


#### Accounting for geographic distance (without altitude)

```{r FormatDataGeoDistSet2}
subdata <- data[,c("prov","latitude_prov","longitude_prov",select.var2)]
colnames(subdata) <- c("prov","longitude","latitude",paste0(str_sub(select.var2,0,-6)))

gdmTab_noalt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_noalt)
```

```{r RunningGDMGeoDistSet2,fig.height=7,fig.width=7}
gdm.5 <- gdm(gdmTab_noalt, geo=T)
gdm.5 

# Deviance explained 
gdm.5$explained

sum(gdm.5$coefficients) # https://rdrr.io/cran/gdm/src/R/GDM_Table_Funcs.R

# Leave-one out cross validation
# sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "r2",geo=T) # R2 # 
# Error message:  Returning NULL object.Error in UseMethod("predict") : 
  # pas de méthode pour 'predict' applicable pour un objet de classe "NULL"
# sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 2,performance = "r2",geo=T)
sgdm::gdm.cv(gdmTab_noalt,nfolds = 6,performance = "r2",geo=T)


par(mfrow=c(2,2))
gdm.5.splineDat <- isplineExtract(gdm.5)

plot(gdm.5.splineDat$x[,"Geographic"], gdm.5.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)

gdm.5.pred <- predict.gdm(gdm.5, gdmTab_noalt) # HERE
plot(gdmTab_noalt$distance, gdm.5.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.5.splineDat[[1]][,"bio12"], gdm.5.splineDat[[2]][,"bio12"], type="l",lwd=3, xlab="Annual precipitation (mm)", ylab="Partial Ecological Distance")
plot(gdm.5.splineDat[[1]][,"bio1"], gdm.5.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Annual T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.5.splineDat[[1]][,"ppet.min"], gdm.5.splineDat[[2]][,"ppet.min"], type="l",lwd=3, xlab="Minimum PPET", ylab="Partial Ecological Distance")
plot(gdm.5.splineDat[[1]][,"bio6"], gdm.5.splineDat[[2]][,"bio6"], type="l",lwd=3, xlab="Minimum T° of the coldest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.5.splineDat[[1]][,"sand_top"], gdm.5.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.5.splineDat[[1]][,"depth_roots"], gdm.5.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
```


Only a small effect of the precipitation of the driest month. The other climatic variables have no effect. Stronger effect of the altitude and the geographic distance.


```{r VizualizeGDM5,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackSoilClimSet2.grd")

rastTrans <- gdm.transform(gdm.5, stackall) 

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```


### Set 3

#### Accounting for geographic distance (with altitude)

```{r FormatDataGeoDistAltSet3}
subdata <- data[,c("prov","latitude_prov","longitude_prov","altitude_prov",select.var3)]
colnames(subdata) <- c("prov","longitude","latitude","altitude",paste0(str_sub(select.var3,0,-6)))

gdmTab_alt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_alt)
```

```{r RunningGDMGeoDistAltSet3,fig.height=7,fig.width=7}
gdm.7 <- gdm(gdmTab_alt, geo=T)
gdm.7

# Deviance explained
gdm.7$explained


# Leave-one out cross validation
sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "r2",geo=T) # R2
sgdm::gdm.cv(gdmTab_alt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_alt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_alt,nfolds = 2,performance = "r2",geo=T)


par(mfrow=c(2,2))
# plot(gdm.1) # automatically return all graphs (but with default legends)
gdm.7.splineDat <- isplineExtract(gdm.7)
# str(gdm.7.splineDat)
plot(gdm.7.splineDat$x[,"Geographic"], gdm.7.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)
gdm.7.pred <- predict.gdm(gdm.7, gdmTab_alt)
# head(gdm.7.pred)


plot(gdmTab_alt$distance, gdm.7.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.7.splineDat[[1]][,"bio14"], gdm.7.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Minimum Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.7.splineDat[[1]][,"bio1"], gdm.7.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Annual T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.7.splineDat[[1]][,"ppet.mean"], gdm.7.splineDat[[2]][,"ppet.mean"], type="l",lwd=3, xlab="Mean PPET", ylab="Partial Ecological Distance")
plot(gdm.7.splineDat[[1]][,"sand_top"], gdm.7.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.7.splineDat[[1]][,"depth_roots"], gdm.7.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
plot(gdm.7.splineDat[[1]][,"altitude"], gdm.7.splineDat[[2]][,"altitude"], type="l",lwd=3, xlab="Altitude", ylab="Partial Ecological Distance")
```


```{r VizualizeGDM7, fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackAltSoilClimSet3.grd")

rastTrans <- gdm.transform(gdm.7, stackall)

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plotRGB(pcaRast, r=1, g=2, b=3)

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```

### Set 4

#### Accounting for geographic distance (without altitude)

```{r FormatDataGeoDistSet4}
subdata <- data[,c("prov","latitude_prov","longitude_prov",select.var4)]
colnames(subdata) <- c("prov","longitude","latitude",paste0(str_sub(select.var4,0,-6)))

gdmTab_noalt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_noalt)
```

```{r RunningGDMGeoDistSet4,fig.height=7,fig.width=7}
gdm.8 <- gdm(gdmTab_noalt, geo=T)
gdm.8

# Deviance explained 
gdm.8$explained

sum(gdm.8$coefficients) # https://rdrr.io/cran/gdm/src/R/GDM_Table_Funcs.R

# Leave-one out cross validation
#sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "r2",geo=T) # R2 # 
# Error message:  Returning NULL object.Error in UseMethod("predict") : 
  # pas de méthode pour 'predict' applicable pour un objet de classe "NULL"
#sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 2,performance = "r2",geo=T)
sgdm::gdm.cv(gdmTab_noalt,nfolds = 6,performance = "r2",geo=T)


par(mfrow=c(2,2))
gdm.8.splineDat <- isplineExtract(gdm.8)

plot(gdm.8.splineDat$x[,"Geographic"], gdm.8.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)

gdm.8.pred <- predict.gdm(gdm.8, gdmTab_noalt)
plot(gdmTab_noalt$distance, gdm.8.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.8.splineDat[[1]][,"bio14"], gdm.8.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.8.splineDat[[1]][,"bio1"], gdm.8.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Annual T° (°C)", ylab="Partial Ecological Distance")
plot(gdm.8.splineDat[[1]][,"ppet.mean"], gdm.8.splineDat[[2]][,"ppet.mean"], type="l",lwd=3, xlab="Mean PPET", ylab="Partial Ecological Distance")
plot(gdm.8.splineDat[[1]][,"ppet.min"], gdm.8.splineDat[[2]][,"ppet.min"], type="l",lwd=3, xlab="Minimum PPET", ylab="Partial Ecological Distance")
plot(gdm.8.splineDat[[1]][,"sand_top"], gdm.8.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.8.splineDat[[1]][,"depth_roots"], gdm.8.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
```



```{r VizualizeGDM8,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackSoilClimSet4.grd")

rastTrans <- gdm.transform(gdm.8, stackall) 

rastDat <- na.omit(getValues(rastTrans))
pcaSamp <- prcomp(rastDat)
pcaRast <- predict(rastTrans, pcaSamp, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)
```


### Set 5

#### Accounting for geographic distance (without altitude)

```{r FormatDataGeoDistSet5}
subdata <- data[,c("prov","latitude_prov","longitude_prov",select.var5)]
colnames(subdata) <- c("prov","longitude","latitude",paste0(str_sub(select.var5,0,-6)))

gdmTab_noalt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_noalt)
```

```{r RunningGDMGeoDistSet5,fig.height=7,fig.width=7}
gdm.9 <- gdm(gdmTab_noalt, geo=T)
gdm.9

# Deviance explained 
gdm.9$explained

sum(gdm.9$coefficients) # https://rdrr.io/cran/gdm/src/R/GDM_Table_Funcs.R

# Leave-one out cross validation
# sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "r2",geo=T) # R2 # 
# Error message:  Returning NULL object.Error in UseMethod("predict") : 
  # pas de méthode pour 'predict' applicable pour un objet de classe "NULL"
#sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 2,performance = "r2",geo=T)
sgdm::gdm.cv(gdmTab_noalt,nfolds = 6,performance = "r2",geo=T)


par(mfrow=c(2,2))
gdm.9.splineDat <- isplineExtract(gdm.9)

plot(gdm.9.splineDat$x[,"Geographic"], gdm.9.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)

gdm.9.pred <- predict.gdm(gdm.9, gdmTab_noalt)
plot(gdmTab_noalt$distance, gdm.9.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.9.splineDat[[1]][,"bio13"], gdm.9.splineDat[[2]][,"bio13"], type="l",lwd=3, xlab="Precipitation of the wettest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.9.splineDat[[1]][,"bio14"], gdm.9.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.9.splineDat[[1]][,"bio5"], gdm.9.splineDat[[2]][,"bio5"], type="l",lwd=3, xlab="Max T° warmest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.9.splineDat[[1]][,"bio6"], gdm.9.splineDat[[2]][,"bio6"], type="l",lwd=3, xlab="Min T° of the driest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.9.splineDat[[1]][,"sand_top"], gdm.9.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.9.splineDat[[1]][,"depth_roots"], gdm.9.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
```

#### Current climate (Fitting the models and projecting)

```{r VizualizeGDM9,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackSoilClimSet5.grd")

rastTrans <- gdm.transform(gdm.9, stackall) 

rastDat <- na.omit(getValues(rastTrans))
pca <- prcomp(rastDat, center=TRUE, scale.=FALSE)

# 1/ Following the GDM vignette (=> projection)
pcaRast <- predict(rastTrans, pca, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)


# 
# 2/ Following the script of the paper of Fitzpatrick and Keller (2014)
# projection + biplot

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)


mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 2, b = 3)

nvs <- dim(pca$rotation)[1]
vec <-  row.names(pca$rotation)
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 20
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
pca$rotation
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)
```




#### Future climate (2041-2060) - GCM BCC-CSM2-MR (SSP245)

```{r VizualizeGDM9FutClim,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP245/StackSoilClimSet5_BCCCSM2MR.grd")

rastTrans <- gdm.transform(gdm.9, stackall) 

rastDat <- na.omit(getValues(rastTrans))
pca <- prcomp(rastDat, center=TRUE, scale.=FALSE)
pcaRast <- predict(rastTrans, pca, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)

# 
# 2/ Following the script of the paper of Fitzpatrick and Keller (2014)
# projection + biplot

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)


mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 2, b = 3)

nvs <- dim(pca$rotation)[1]
vec <-  row.names(pca$rotation)
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 10
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
pca$rotation
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)

# Change the arrow size
scal <- 20
xrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) *1.1
yrng <- range(pca$x[, 3], pca$rotation[, 3]/scal) * 1.1
plot((pca$x[, 2:3]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 2:3]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,2]/scal, pca$rotation[vec, 3]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     pca$rotation[vec, 3]/scal + jit * sign(pca$rotation[vec, 3]), 
     labels = vec)
```


> Genomic offset

```{r GenomicOffsetSet5}
stack.cur.clim <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/StackSoilClimSet5ResWorldClim.grd"))
stack.fut.clim <- stack(paste0("../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP370/StackSoilClimSet5_BCCCSM2MR.grd"))

# rasValue <- raster::extract(stack.cur.clim, shp,cellnumbers=T)
# rasValue <- as.data.frame(rasValue)
#rasValue <- na.omit(rasValue)

genOffBS <- predict.gdm(gdm.9, data=stack.cur.clim,time=TRUE, predRasts=stack.fut.clim) 
# rastDat <- na.omit(getValues(rastTrans))
# pcaSamp <- prcomp(rastDat)
# projCurResWorldClim <- predict(rastTrans, pcaSamp, index=1:3)
# mean(projCurResWorldClim)
# 
# # calculate euclidean distance between current and future genetic spaces  
# genOffBS <- sqrt((projCurResWorldClim[,1]-predFut[,1])^2+(projCurResWorldClim[,2]-predFut[,2])^2
#                     +(projCurResWorldClim[,3]-predFut[,3])^2+(projCurResWorldClim[,4]-predFut[,4])^2
#                     +(projCurResWorldClim[,5]-predFut[,5])^2+(projCurResWorldClim[,6]-predFut[,6])^2)
# 
# 
# # assign values to raster - can be tricky if current/future climate
# # rasters are not identical in terms of # cells, extent, etc.
# values <- raster::extract(stackall, shp,cellnumbers=T)
# 
plot(genOffBS)
```


#### Future climate (2041-2060) - All GCMs (SSP370)


```{r Set5BeforeSelectionFutClimAllGCMsCalculateGoSSP370}
stack.cur.clim <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/StackSoilClimSet5ResWorldClim.grd"))
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP370/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

model <- gdm.9

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRangeWithGDM)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```


```{r Set5BeforeSelectionFutClimAllGCMsPlotsSSP585, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Keeping mean and SD for futher analyses
DFtotssp585 <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanBS=mean,SdBS=sd)
```

```{r PlotGOSet5BeforeSelectionFutClimAllGCMsSSP585,fig.height=8,fig.width=10}
rast.go <- stackall[[1]]
rast.go[rasValue$cell] <- dfGOallGCMs$mean
plot(rast.go,box = FALSE,
     axes = FALSE,
     alpha=0.8,
      col=colorRampPalette(c("blue","yellow","red"))(255),
     zlim=c(0,0.1))
```

```{r PlotFuturePredictionsAllGCMsSSP585, fig.height=6,fig.width=8}
meanIgnoringZeroes <- function(x) {
  mean(x[x!=0],na.rm=T)}

meanbio13 <- overlay(fut.clim.stacks[[1]][[1]],
                fut.clim.stacks[[2]][[1]],
                fut.clim.stacks[[3]][[1]],
                fut.clim.stacks[[4]][[1]],
                fut.clim.stacks[[5]][[1]],
                fut.clim.stacks[[6]][[1]],
                fut.clim.stacks[[7]][[1]],
                fut.clim.stacks[[8]][[1]],
                fut.clim.stacks[[9]][[1]],
                fun=meanIgnoringZeroes)

meanbio14 <- overlay(fut.clim.stacks[[1]][[2]],
                fut.clim.stacks[[2]][[2]],
                fut.clim.stacks[[3]][[2]],
                fut.clim.stacks[[4]][[2]],
                fut.clim.stacks[[5]][[2]],
                fut.clim.stacks[[6]][[2]],
                fut.clim.stacks[[7]][[2]],
                fut.clim.stacks[[8]][[2]],
                fut.clim.stacks[[9]][[2]],
                fun=meanIgnoringZeroes)

meanbio5 <- overlay(fut.clim.stacks[[1]][[3]],
                fut.clim.stacks[[2]][[3]],
                fut.clim.stacks[[3]][[3]],
                fut.clim.stacks[[4]][[3]],
                fut.clim.stacks[[5]][[3]],
                fut.clim.stacks[[6]][[3]],
                fut.clim.stacks[[7]][[3]],
                fut.clim.stacks[[8]][[3]],
                fut.clim.stacks[[9]][[3]],
                fun=meanIgnoringZeroes)

meanbio6 <- overlay(fut.clim.stacks[[1]][[4]],
                fut.clim.stacks[[2]][[4]],
                fut.clim.stacks[[3]][[4]],
                fut.clim.stacks[[4]][[4]],
                fut.clim.stacks[[5]][[4]],
                fut.clim.stacks[[6]][[4]],
                fut.clim.stacks[[7]][[4]],
                fut.clim.stacks[[8]][[4]],
                fut.clim.stacks[[9]][[4]],
                fun=meanIgnoringZeroes)

meanStackAllGCMs <- stack(meanbio13,
                          meanbio14,
                          meanbio5,
                          meanbio6,
                          fut.clim.stacks[[1]][[5]],
                          fut.clim.stacks[[1]][[6]])

names(meanStackAllGCMs) <- names(fut.clim.stacks[[1]])

rastTransAllGCMs <- gdm.transform(model, meanStackAllGCMs)
rastDatAllGCMs <-  na.omit(getValues(rastTransAllGCMs))
rastDatAllGCMs <- as.data.frame(rastDatAllGCMs)


pca <- prcomp(rastDatAllGCMs, center=TRUE, scale.=FALSE) # bio5 does not appear as this variable has no explanatory power

# 1/ Following the GDM vignette (=> projection)
pcaRast <- predict(rastTransAllGCMs, pca, index=1:3) # HERE

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)


# 
# 2/ Following the script of the paper of Fitzpatrick and Keller (2014)
# projection + biplot

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- meanStackAllGCMs[[1]]

rasValue <- raster::extract(meanStackAllGCMs[[-3]], shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)


mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 2, b = 3)

nvs <- dim(pca$rotation)[1]
vec <-  row.names(pca$rotation)
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 10
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
pca$rotation
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)
```


## Interpretation

- Geographic distance is highly important, always the most important variable. Expected in maritime pine.

- Altitude is also very important, and I did not manage to find variables that could replace it (variables that are highly correlated to altitude do not have the same influence on the genomic composition).

- Soil has a small but always different from zero effect (depth roots and sand top)

- Mean precipitation and T° have no effect, it is more variables representing extreme conditions that have an effect, e.g. precipitation of the driest month. 


## Building by hand the input dataframe


```{r MeltingFstMat,fig.height=7,fig.width=7, eval=F}
# Dataframe of genetic distance (Fst) between each pair of provenance
fst <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsBS.rds")
meltfst <- melt(fst)
#meltfst <- meltfst %>% select(Var2,Var1,value)
colnames(meltfst) <- c("prov1","prov2","distance")
head(meltfst)
meltfst <- na.omit(meltfst)


# Merging with environmental and geographical data
data <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
data <- data %>% select(contains("prov"))
data <- unique(data)
data

# Select env variables
select.var <- c(paste0("bio",c(1,5,12,14),"_prov"),"sand_top_prov","depth_roots_prov")

# MERGING ALL
# First provenance
data1 <- data[,c("prov","latitude_prov","longitude_prov","altitude_prov",select.var)]
colnames(data1) <- c("prov1","s1.xCoord","s1.yCoord","s1.altitude",paste0("s1.",str_sub(select.var,0,-6)))

# Second provenance
data2 <- data[,c("prov","latitude_prov","longitude_prov","altitude_prov",select.var)]
colnames(data2) <- c("prov2","s2.xCoord","s2.yCoord","s2.altitude",paste0("s2.",str_sub(select.var,0,-6)))

data <- merge(meltfst,data1,by="prov1")
data <- merge(data,data2,by="prov2")
data

# Check if there are some NAs.
sum(is.na(data))

# Save
#saveRDS(data,file="../../outputs/GDM/DataPreparedBeforeGDM.rds")
#data <- readRDS(file="../../outputs/GDM/DataPreparedBeforeGDM.rds")


# preparing data
gdmData <- data[,3:length(colnames(data))]
gdmData$weights <- 1
gdmData <- gdmData %>% select(distance,weights, s1.xCoord, s1.yCoord, s2.xCoord, s2.yCoord,everything())
class(gdmData) <- c("gdmData", "data.frame")
str(gdmData)

# run
gdmOutput <- gdm(gdmData,geo = T)

# Deviance explained
gdmOutput$explained

# plots
par(mfrow=c(2,2))
gdmOutput.splineDat <- isplineExtract(gdmOutput)
plot(gdmOutput.splineDat$x[,"Geographic"], gdmOutput.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)
gdmOutput.pred <- predict(gdmOutput, gdmData)


plot(gdmData$distance, gdmOutput.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))
tabTrans <- gdm.transform(gdmOutput, data[,-1])
tabTrans

plot(gdmOutput.splineDat[[1]][,"bio1"], gdmOutput.splineDat[[2]][,"bio1"], type="l",lwd=3, xlab="Mean T° (°C)", ylab="Partial Ecological Distance")
plot(gdmOutput.splineDat[[1]][,"bio5"], gdmOutput.splineDat[[2]][,"bio5"], type="l",lwd=3, xlab="T° of the warmest month (°C)", ylab="Partial Ecological Distance")
plot(gdmOutput.splineDat[[1]][,"bio12"], gdmOutput.splineDat[[2]][,"bio12"], type="l",lwd=3, xlab="Annual precipitation (mm)", ylab="Partial Ecological Distance")
plot(gdmOutput.splineDat[[1]][,"bio14"], gdmOutput.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdmOutput.splineDat[[1]][,"sand_top"], gdmOutput.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdmOutput.splineDat[[1]][,"depth_roots"], gdmOutput.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
plot(gdmOutput.splineDat[[1]][,"altitude"], gdmOutput.splineDat[[2]][,"altitude"], type="l",lwd=3, xlab="Altitude", ylab="Partial Ecological Distance")

```

This is the same as before (when using the 'formatsitepair' function), great. 



# AFTER SELECTION in Madrid and Caceres

Here we remove the genotypes for which no individual has survived neither in Madrid nor in Cáceres. 

## Load data

### Fst matrix

```{r LoadFstMatrixASCacMad,eval=F}
fst <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsBS.rds")
fst <- as.data.frame(fst) 
fst <- fst %>%  tibble::rownames_to_column("prov") # The distance matrix must have as the first column the names of the provenances
```



# AFTER SELECTION in Caceres

Here we remove the genotypes for which no individual has survived neither in Madrid nor in Cáceres. 

## Load data

### Fst matrix

```{r LoadFstMatrixASCacOnly}
fst <- readRDS(file="../../data/PreparedDFforGDMandGF/GDM/FstMatrices/FstMatrix5165Snps34ProvsASCacOnly.rds")
fst <- as.data.frame(fst) 
fst <- fst %>%  tibble::rownames_to_column("prov") # The distance matrix must have as the first column the names of the provenances
mean(unlist(fst[,-1]),na.rm=T)
range(unlist(fst[,-1]),na.rm=T)
sd(unlist(fst[,-1]),na.rm=T)
```



## Set 5

#### Accounting for geographic distance (without altitude)

```{r FormatDataGeoDistSet5CacOnly}
subdata <- data[,c("prov","latitude_prov","longitude_prov",select.var5)]
colnames(subdata) <- c("prov","longitude","latitude",paste0(str_sub(select.var5,0,-6)))

setdiff(subdata$prov,colnames(fst)) # Provenance "MAD" did not have some genotypes that survived during the strong drought events in Madrid and Caceres. We are going to remove it from the dataset for the following analyses. 

subdata <- subdata[!subdata$prov=="MAD",]

gdmTab_noalt <- formatsitepair(fst, bioFormat=3, XColumn="longitude", YColumn="latitude",siteColumn="prov",
 predData=subdata)
head(gdmTab_noalt)
```

```{r RunningGDMGeoDistSet5CacOnly,fig.height=7,fig.width=7}
gdm <- gdm(gdmTab_noalt, geo=T)

# Deviance explained 
gdm$explained

sum(gdm$coefficients) # https://rdrr.io/cran/gdm/src/R/GDM_Table_Funcs.R

# Leave-one out cross validation
#sgdm::gdm.cv(gdmTab_noalt,nfolds = 33,performance = "r2",geo=T) # R2 # 
# Error message:  Returning NULL object.Error in UseMethod("predict") : 
  # pas de méthode pour 'predict' applicable pour un objet de classe "NULL"
#sgdm::gdm.cv(gdmTab_noalt,nfolds = 34,performance = "rmse",geo=T) # RMSE

# Cross validation with 17 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 17,performance = "r2",geo=T)

# Cross validation with 2 folds
sgdm::gdm.cv(gdmTab_noalt,nfolds = 2,performance = "r2",geo=T) # working!
sgdm::gdm.cv(gdmTab_noalt,nfolds = 6,performance = "r2",geo=T)


par(mfrow=c(2,2))
gdm.splineDat <- isplineExtract(gdm)

plot(gdm.splineDat$x[,"Geographic"], gdm.splineDat$y[,"Geographic"], lwd=3,
type="l", xlab="Geographic distance", ylab="Partial ecological distance") # or ylab= f(Geographic distance)

gdm.pred <- predict.gdm(gdm, gdmTab_noalt)
plot(gdmTab_noalt$distance, gdm.pred, xlab="Observed genetic distance",
ylab="Predicted genetic distance", pch=20, col=rgb(0,0,1,0.5))
lines(c(-1,2), c(-1,2))

plot(gdm.splineDat[[1]][,"bio13"], gdm.splineDat[[2]][,"bio13"], type="l",lwd=3, xlab="Precipitation of the wettest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.splineDat[[1]][,"bio14"], gdm.splineDat[[2]][,"bio14"], type="l",lwd=3, xlab="Precipitation of the driest month (mm)", ylab="Partial Ecological Distance")
plot(gdm.splineDat[[1]][,"bio5"], gdm.splineDat[[2]][,"bio5"], type="l",lwd=3, xlab="Max T° warmest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.splineDat[[1]][,"bio6"], gdm.splineDat[[2]][,"bio6"], type="l",lwd=3, xlab="Min T° of the driest month (°C)", ylab="Partial Ecological Distance")
plot(gdm.splineDat[[1]][,"sand_top"], gdm.splineDat[[2]][,"sand_top"], type="l",lwd=3, xlab="Sand top (%)", ylab="Partial Ecological Distance")
plot(gdm.splineDat[[1]][,"depth_roots"], gdm.splineDat[[2]][,"depth_roots"], type="l",lwd=3, xlab="Depth roots", ylab="Partial Ecological Distance")
```

#### Current climate (Fitting the models and projecting)

```{r VizualizeGDMCacOnly,fig.height=7,fig.width=10}
stackall <- stack("../../data/StacksEnvVars/StackSoilClimSet5.grd")

rastTrans <- gdm.transform(gdm, stackall) 

rastDat <- na.omit(getValues(rastTrans))
pca <- prcomp(rastDat, center=TRUE, scale.=FALSE)

# 1/ Following the GDM vignette (=> projection)
pcaRast <- predict(rastTrans, pca, index=1:3)

pcaRast[[1]] <- (pcaRast[[1]]-pcaRast[[1]]@data@min) /
(pcaRast[[1]]@data@max-pcaRast[[1]]@data@min)*255
pcaRast[[2]] <- (pcaRast[[2]]-pcaRast[[2]]@data@min) /
(pcaRast[[2]]@data@max-pcaRast[[2]]@data@min)*255
pcaRast[[3]] <- (pcaRast[[3]]-pcaRast[[3]]@data@min) /
(pcaRast[[3]]@data@max-pcaRast[[3]]@data@min)*255

plot(background,col=grayscale_colors, axes=FALSE,legend=F)
plotRGB(pcaRast,add=T,bgalpha=0)


# 
# 2/ Following the script of the paper of Fitzpatrick and Keller (2014)
# projection + biplot

##assigns to colors, edit as needed to maximize color contrast, etc.
a1 <- pca$x[,1]; a2 <- pca$x[,2]; a3 <- pca$x[,3]
r <- a1+a2; g <- -a2; b <- a3+a2-a1

##scales colors
scalR <- (r-min(r))/(max(r)-min(r))*255
scalG <- (g-min(g))/(max(g)-min(g))*255
scalB <- (b-min(b))/(max(b)-min(b))*255

##assigns color to raster
rast1 <- rast2 <- rast3 <- stackall[[1]]

rasValue <- raster::extract(stackall, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)


mapCells <- rasValue$cell
rast1[mapCells] <- scalR
rast2[mapCells] <- scalG
rast3[mapCells] <- scalB
##stacks color rasters
outRast <- stack(rast1, rast2, rast3)
plotRGB(outRast, r = 1, g = 2, b = 3)

nvs <- dim(pca$rotation)[1]
vec <-  row.names(pca$rotation)
lv <- length(vec)
vind <- rownames(pca$rotation) %in% vec
scal <- 40
xrng <- range(pca$x[, 1], pca$rotation[, 1]/scal) *1.1
yrng <- range(pca$x[, 2], pca$rotation[, 2]/scal) * 1.1
pca$rotation
plot((pca$x[, 1:2]), xlim = xrng, ylim = yrng, pch = ".", cex = 4, col = rgb(scalR , scalG, scalB, max = 255), asp = 1)
points(pca$rotation[!vind, 1:2]/scal, pch = "+")
arrows(rep(0, lv), rep(0, lv), pca$rotation[vec,1]/scal, pca$rotation[vec, 2]/scal, length = 0.0625)
jit <- 0.0015
text(pca$rotation[vec, 1]/scal + jit * sign(pca$rotation[vec, 1]), 
     pca$rotation[vec, 2]/scal + jit * sign(pca$rotation[vec, 2]), 
     labels = vec)
```

#### Future climate (2041-2060) - All GCMs (SSP370)


```{r Set5AfterSelectionCacOnlyFutClimAllGCMsCalculateGoSSP370}
stack.cur.clim <- stack(paste0("../../data/StacksEnvVars/CurStacksResWorldClim/StackSoilClimSet5ResWorldClim.grd"))
path="../../data/StacksEnvVars/FutClimStacks/2041to2060/SSP370/"
fut.clim.stacks.names <- list.files(path=path,pattern="grd$")
# Load the stacks in a list
fut.clim.stacks <- lapply(fut.clim.stacks.names, function(t) stack(paste0(path,t)))

model <- gdm

# Calculate the GO for each GCM
genOffallGCMs <- lapply(fut.clim.stacks, GOAcrossRangeWithGDM)
names(genOffallGCMs) <- str_sub(fut.clim.stacks.names,19,-5)

# convert to DF 
dfGOallGCMs <- as.data.frame(genOffallGCMs)
```


```{r Set5AfterSelectionCacOnlyFutClimAllGCMsPlotsSSP370, fig.height=3,fig.width=6}
# Distribution of the genomic offset for each GCM
dfGOallGCMs %>%  
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")


dfGOallGCMs$mean <- apply(dfGOallGCMs,1,mean)
dfGOallGCMs$sd <- apply(dfGOallGCMs,1,sd)
dfGOallGCMs$sdSup <- dfGOallGCMs$mean + dfGOallGCMs$sd
dfGOallGCMs$sdInf <- dfGOallGCMs$mean - dfGOallGCMs$sd
dfGOallGCMs$seSup <- dfGOallGCMs$mean + dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))
dfGOallGCMs$seInf <- dfGOallGCMs$mean - dfGOallGCMs$sd/sqrt(length(dfGOallGCMs$mean))


# Distribution of mean GO and its SE
dfGOallGCMs %>%  
  dplyr::select(mean,seSup,seInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Distribution of mean GO and SD Supp and Inf
dfGOallGCMs %>%  
  dplyr::select(mean,sdSup,sdInf) %>% 
  pivot_longer(cols=everything(),names_to="model",values_to="go") %>% 
  ggplot(aes(x=go,color=model)) + 
    geom_density(size=1.5) +
    theme_bw() + 
    xlab("Genomic offset")

# Comparing with BeforeSelection and AfterSelectionCacMad
dfGOallGCMs <- dfGOallGCMs %>% dplyr::select(mean,sd) %>% dplyr::rename(MeanAScac=mean,SdAScac=sd)
DFtotssp585 <- bind_cols(DFtotssp585,dfGOallGCMs)

DFtotssp585 %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=go,color=subset)) + 
    geom_density(size=1.5) +
    theme_bw() #+ 
    # xlab("Genomic offset")  +
    # scale_color_discrete(name = "Subset of\n genotypes", labels = c("After selection in Caceres",
    #                                                                 #"After selection in Madrid and Caceres",
    #                                                                 "Before Selection"))
DFtotssp585 %>% 
  pivot_longer(cols=contains("Mean"),names_to="subset",values_to="go") %>% 
  ggplot(aes(x=subset, y=go, fill=subset)) + 
    geom_boxplot(alpha=0.6) + 
    theme_bw() +
    # scale_fill_discrete(name = "Subset of\n genotypes",
    #                   labels = c("After selection in Caceres",
    #                              #"After selection in Madrid and Caceres",
    #                              "Before Selection")) +
    ylab("Genomic offset") +
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
```

```{r PlotGOSet5AfterSelectionCacOnlyFutClimAllGCMsSSP370,fig.height=6,fig.width=8}
rast.go <- fut.clim.stacks[[1]][[1]]

rasValue <- raster::extract(rast.go, shp,cellnumbers=T)
rasValue <- as.data.frame(rasValue)
rasValue <- na.omit(rasValue)

rast.go[rasValue$cell] <- dfGOallGCMs$MeanAScac
plot(rast.go,box = FALSE,
     axes = FALSE,
     alpha=0.8,
      col=colorRampPalette(c("blue","yellow","red"))(255),
     zlim=c(0,0.1))
```


`r knitr::opts_chunk$set(eval = F)`



---
title: 'Multilocus genetic-environment association: Redundancy Analysis (RDA)'
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
editor_options: 
  chunk_output_type: console
---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 5,fig.height = 4,cache=FALSE)
options(width = 300)
library(knitr)
library(vegan)  # to investigate correlations among predictors
library(psych)  # to run RDA and to plot the pairs panels
library(tidyverse)
library(adespatial) # to calculate the Moran eigen vectors
library(kableExtra)
```

This script is based on [Forester et al. (2018)](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14584) and their [vignette](https://popgen.nescent.org/2018-03-27_RDA_GEA.html). All the <span style="color: gray;">quotes in gray</span> in the document come from this vignette.


Notes on **correction for population structure** from [Forester et al. (2018)](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14584).

In their paper, they investigate the effects of correction for **weak** population structure only. In their conclusion: "It is important to note that population structure was relatively low in these simulations. Results may differ for systems with strong population structure or metapopulation dynamics, where it can be important to correct for structure or combine detections with another GEA that accounts for structure."

# DATA



## Genomic data

The genomic dataset contains 523 genotypes and 5,165 SNPs. Missing data were imputed using the most common allele at each SNP within the gene pool.

```{r LoadGenomicData}
gen.imp <- readRDS(file="data/GenomicData/5165snps523genotypesImpNA.rds")
```


## Environmental and population structure data

```{r LoadEnvData}
env <- readRDS(file="data/AllDataPhenoClimSoil.RDS")
env <- env %>% select(clon,prov,contains("ude_prov"),contains("bio"),contains("top_prov"),"depth_roots_prov", paste0(rep("Q",6),1:6),max.Q)
colnames(env) <- c("genotype","prov",str_sub(grep("_prov",colnames(env),value=TRUE),1,-6),paste0(rep("Q",6),1:6),"maxgp")
env <- unique(env)
env <- env[!(env$prov=="ROD"),]

topo <- readRDS(file="data/Topography/DfTopoVarbyProv.rds")
topo <- topo %>% dplyr::select(prov,TRI_WGS84_90m_R) %>% 
                 dplyr::rename(TRI=TRI_WGS84_90m_R)
env <- merge(env,topo,by="prov")
env

env <- env[env$genotype %in% rownames(gen.imp),]
```

We run the RDA on four different sets of environemntal variables.

### Set AvgSand

Topographic variable: `TRI`.

Soil variables:

  - `sand_top` = sand content in the top layers of the soil
  - `depth_roots` = Depth available to roots

Climatic variables representing average climatic conditions:

  - `bio1`: annual daily mean temperature (°C)
  - `bio2`: mean diurnal temperature range (max-min, °C)
  - `bio12`: annual precipitation (mm)
  - `bio14`: precipitation of the driest month (mm)
  
```{r SetAvgSand,fig.height=9,fig.width=12}
select.var.AvgSand <- c("bio1","bio2","bio12","bio14","sand_top","depth_roots","TRI")
pairs.panels(unique(env[,select.var.AvgSand]), scale=T) # unique() here because there is one env. value per provenance
```

### Set AvgWater

Topographic variable: `TRI`.

Soil variables:

  - `water_top` = Total available water content
  - `depth_roots` = Depth available to roots

Climatic variables representing average climatic conditions:

  - `bio1`: annual daily mean temperature (°C)
  - `bio2`: mean diurnal temperature range (max-min, °C)
  - `bio12`: annual precipitation (mm)
  - `bio14`: precipitation of the driest month (mm)
  
```{r SetAvgWater,fig.height=9,fig.width=12}
select.var.AvgWater <- c("bio1","bio2","bio12","bio14","water_top","depth_roots","TRI")
pairs.panels(unique(env[,select.var.AvgWater]), scale=T) # unique() here because there is one env. value per provenance
```

### Set ExtSand

Topographic variable: `TRI`.

Soil variables:

  - `sand_top` = sand content in the top layers of the soil
  - `depth_roots` = Depth available to roots

Climatic variables representing episodic events:

  - `bio5`: max temperature of the warmest month (°C)
  - `bio6`: min temperature of the coldest month (°C)
  - `bio13`: precipitation of the wettest month (mm)
  - `bio14`: precipitation of the driest month (mm)
  
  
```{r SetExtSand,fig.height=9,fig.width=12}
select.var.ExtSand <- c("bio13","bio14","bio5","bio6","sand_top","depth_roots","TRI")
pairs.panels(unique(env[,select.var.ExtSand]), scale=T)
```



### Set ExtWater

Topographic variable: `TRI`.

Soil variables:

  - `water_top` = sand content in the top layers of the soil
  - `depth_roots` = Depth available to roots

Climatic variables representing episodic events:

  - `bio5`: max temperature of the warmest month (°C)
  - `bio6`: min temperature of the coldest month (°C)
  - `bio13`: precipitation of the wettest month (mm)
  - `bio14`: precipitation of the driest month (mm)
  
  
```{r SetExtWater,fig.height=9,fig.width=12}
select.var.ExtWater <- c("bio13","bio14","bio5","bio6","water_top","depth_roots","TRI")
pairs.panels(unique(env[,select.var.ExtWater]), scale=T)
```

# Set AvgWater

## RDA not corrected by population structure

### run the RDA

<span style="color: gray;">"[...] we highly recommend Borcard et al. (2011) for details on the implementation and interpretation of RDA models and the objects created by vegan. RDA runs relatively quickly on most data sets, however on a very large data set it can take 15-20 minutes, depending on the computer.

Note: if your predictors include any factors, you’ll need to write out the formula in the rda call if you want to include a significance test of the constrained axis. Since we are not using any factors in this analysis, we can use the shorthand formula `gen.imp ~ .`"</span>


```{r RDAnocorrectionRunAvgWater}
nocorrection.rda <- rda(gen.imp ~ ., data=env[,select.var.AvgWater], scale=T)
nocorrection.rda
```

<span style="color: gray;">"note that we will have as many constrained (“RDA”) axes as we have predictors in the model. All residual variance is then modeled by PCA (the unconstrained “PC” axes). The proportion of the variance explained by the environmental predictors is given under the “Proportion” column for “Constrained”; this is equivalent to the $\mathcal{R}^{2}$ of a multiple regression. Just like in multiple regression, this $\mathcal{R}^{2}$ will be biased and should be adjusted based on the number of predictors."</span>
That's why we calculate the adjusted $\mathcal{R}^{2}$ using the function `RsquaredAdj`, as below:

```{r RsquareAdjRDAnocorrectionAvgWater}
RsquareAdj(nocorrection.rda)
```

In our case, the constrained ordination explains about 9% of the variation. <span style="color: gray;">"this low explanatory power is not surprising given that we expect that most of the SNPs in our dataset will not show a relationship with the environmental predictors (e.g., most SNPs will be neutral)."</span>

<span style="color: gray;">"The eigenvalues for the constrained axes reflect the variance explained by each canonical axis, as shown by the function `summary(eignevals(..., model="constrained"))`."</span>

```{r SummaryEigneValsRDAnocorrectionAvgWater}
summary(eigenvals(nocorrection.rda, model = "constrained"))
```

<span style="color: gray;">"We can visualize this information using a screeplot of the canonical eigenvalues by calling `screeplot`:"</span>

<span style="color: gray;">"The screeplot provides an informal (and quick) way to determine how many constrained axes to include when we search for candidate SNPs (below). We could start by investigating RDA axes that explain the most variance (excluding those after the “drop off” point in the screeplot.)</span>

```{r ScreeplotRDAnocorrectionAvgWater}
screeplot(nocorrection.rda)
```


> The first constrained axis explain most of the variance (53%). 

<span style="color: gray;">Now let’s check our RDA model for significance using formal tests. We can assess both the full model and each constrained axis using F-statistics (Legendre et al, 2010). The null hypothesis is that no linear relationship exists between the SNP data and the environmental predictors. See ?anova.cca for more details and options."</span>


```{r RDAnocorrectionSigniFullAvgWater, cache=T}
signif.full <- anova.cca(nocorrection.rda, parallel=getOption("mc.cores")) # default is permutation=999
signif.full
```

> The full model is significant. 

<span style="color: gray;">"The full model is significant, but that doesn’t tell us much. We can check each constrained axis for significance using the code below. For this test, each constrained axis is tested using all previous constrained axes as conditions. See `?anova.cca` and Legendre et al. (2010) for details. The purpose here is to determine which constrained axes we should investigate for candidate loci. [...] This analysis is time intensive."</span>

`?anova.cca` "Setting by = "axis" will perform separate significance tests for each constrained axis. All previous constrained axes will be used as conditions (“partialled out”) and a test for the first constrained eigenvalues is performed (Legendre et al. 2011). You can stop permutation tests after exceeding a given significance level with argument cutoff to speed up calculations in large models."

```{r RDAnocorrectionSigniAxisAvgWater, cache=T}
signif.axis <- anova.cca(nocorrection.rda, by="axis", parallel=getOption("mc.cores"))
signif.axis
```

> All the constrained axes are significant, is it not weird?

<span style="color: gray;">"Finally, `vegan` has a simple function for checking Variance Inflation Factors for the predictor variables used in the model:"</span>

```{r RDAnocorrectionVIFAvgWater}
vif.cca(nocorrection.rda)
```

<span style="color: gray;">"All values are below 10, and most are below 5, which indicates that multicollinearity among these predictors shouldn’t be a problem for the model."</span>

### plot the RDA

<span style="color: gray;">"We’ll start with simple triplots from `vegan`. Here we’ll use scaling=3 (also known as “symmetrical scaling”) for the ordination plots. This scales the SNP and individual scores by the square root of the eigenvalues. See Borcard et al. (2011) or the `vegan` help for more information on scaling in RDA plots."</span>

- <span style="color: red;">The SNPs are the red points in the center of each plot.</span>

- The genotypes are the black circles.

- <span style="color: blue;">The blue vectors are the environmental predictors.</span> 

```{r PlotRDAnocorrectionbasePlotsAvgWater, fig.height=6,fig.width=6}
plot(nocorrection.rda, scaling=3)          # default is axes 1 and 2
plot(nocorrection.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

<span style="color: gray;">"The relative arrangement of these items in the ordination space reflects their relationship with the ordination axes, which are linear combinations of the predictor variables."</span>

> More informative plots: the **genotypes** points are colored based on the **main gene pool** the belong to.

```{r PlotRDAnocorrectionAvgWater, fig.height=8,fig.width=8}
levels(env$maxgp) <- c("Northern Africa","Corsica","Central Spain","French Atlantic","Iberian Atlantic","South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3") # same colors as in paper 1

# axes 1 & 2
plot(nocorrection.rda, type="n", scaling=3)
points(nocorrection.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(nocorrection.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(nocorrection.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)

# axes 1 & 3
plot(nocorrection.rda, type="n", scaling=3, choices=c(1,3))
points(nocorrection.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(nocorrection.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(nocorrection.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topleft", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

> <span style="color: red;">We can clearly see here that the ordination space is driven by population structure. We have to correct RDA by population structure.</span>

## RDA corrected by population structure with Moran eigen's vectors


Here, we run a **partial RDA**, conditionned on distance-based MEMs (dbMEM spatial eigenfunctions) calculated from a geographic distance matrix with the function `dbmem` from the `adespatial` package. See section 2.7 in [Forester et al. (2018)](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14584).

Information on Moran eigenvectors: 

- https://cran.r-project.org/web/packages/adespatial/vignettes/tutorial.html

- http://biol09.biol.umontreal.ca/PLcourses/Spatial_eigenfunction_modelling.pdf

I have to verify if it is ok how I calculated the Moran eigenvectors here:

- Do I have to calculate them with one genotype per row or one prov per row? 

- How do I know which are the significant MEMs? 

- Here I use the distance-based Moran's eigenvector maps but there are many other possibilities given different values, e.g. PCNM (can be calculated with the function `pcnm` of the `vegan` package), the Moran’s Eigenvectors Maps (provided by the functions `scores.listw` or `mem` of the `adespatial` package. These two functions are exactly identical, both are kept for historical reasons and compatibility)


```{r MEMsAvgWater}
# Calculate the distance-based MEM with one row per genotype
#mem <- env %>% select(latitude,longitude) %>% dbmem(MEM.autocor = c("positive"),store.listw = FALSE)
#env <- bind_cols(env,mem)

# Calculate the distance-based MEM with one row per prov
provs <- env %>% select(prov,latitude,longitude) %>% distinct()
mem <- provs %>% select(latitude,longitude) %>% dbmem(MEM.autocor = c("positive"),store.listw = FALSE)
mem <- bind_cols(provs,mem)
env <- merge(env,mem,by=c("prov","latitude","longitude"))
```

There are 4 MEMs with a positive autocorrelation (MEMs associated to positive eigenvalues). 

### run the RDA

```{r RDAncorrectionMEMsAvgWater}
correctionmem.rda <- rda(gen.imp ~ bio1 + bio2 + bio12 + bio14 + water_top + depth_roots + TRI + Condition(MEM1 + MEM2 + MEM3 + MEM4),
                         data=env[,c(select.var.AvgWater,paste0(rep("MEM",4),1:4))],
                         scale=T)
# correctionmem.rda <- rda(X=gen.imp ,Y=env[,select.var.AvgWater], Z=mem,scale=T) # same
correctionmem.rda
RsquareAdj(correctionmem.rda)
summary(eigenvals(correctionmem.rda, model = "constrained"))
screeplot(correctionmem.rda)
```

### plot the RDA

```{r PlotRDAcorrectionMEMsbasePlotsAvgWater, fig.height=6,fig.width=7}
plot(correctionmem.rda, scaling=3)          # default is axes 1 and 2
plot(correctionmem.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

```{r PlotRDAcorrectionMEMsAvgWater, fig.height=8,fig.width=8}
levels(env$maxgp) <- c("Northern Africa","Corsica","Central Spain","French Atlantic","Iberian Atlantic","South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3") # same colors as in paper 1

# axes 1 & 2
plot(correctionmem.rda, type="n", scaling=3)
points(correctionmem.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(correctionmem.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(correctionmem.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctionmem.rda, type="n", scaling=3, choices=c(1,3))
points(correctionmem.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(correctionmem.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(correctionmem.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topleft", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

> <span style="color: red;">We can see that the population structure is not well taken into account with the distance-based Moran's eigenvector maps.</span>

## RDA corrected by the population structure with the ancestry coefficients

### run the RDA

```{r RDAncorrectionGPsAvgWater}
correctiongp.rda <- rda(gen.imp ~ bio1 + bio2 + bio12 + bio14 + water_top + depth_roots + TRI + Condition(Q1 + Q2 + Q3 + Q4 + Q4 + Q5), data=env[,c(select.var.AvgWater,paste0(rep("Q",5),1:5))], scale=T)
# correctiongp.rda <- rda(X=gen.imp ,Y=env[,select.var.AvgWater], Z=env[,paste0(rep("Q",6),1:6)],scale=T)  # Same as the line beofre, but if I use this formulation, I can't use annova.cca by "axis".
correctiongp.rda
RsquareAdj(correctiongp.rda)
summary(eigenvals(correctiongp.rda, model = "constrained"))
screeplot(correctiongp.rda)
```

```{r RDAcorrectionGPsSigniFullAvgWater, cache=T}
signif.full <- anova.cca(correctiongp.rda, parallel=getOption("mc.cores")) # default is permutation=999
signif.full
```

```{r RDAcorrectionGPsSigniAxisAvgWater, cache=T}
signif.axis <- vegan::anova.cca(correctiongp.rda,by="axis", parallel=getOption("mc.cores"))
signif.axis
```

> All axes are significant! 

```{r RDAcorrectionGPsVIFAvgWater}
vif.cca(correctiongp.rda)
```

### plot the RDA

```{r PlotRDAcorrectionGPsbasePlotsAvgWater, fig.height=6,fig.width=8}
plot(correctiongp.rda, scaling=3)          # default is axes 1 and 2
plot(correctiongp.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

```{r PlotRDAcorrectionGPsAvgWater, fig.height=10,fig.width=10}
levels(env$maxgp) <- c("Northern Africa",
                       "Corsica",
                       "Central Spain",
                       "French Atlantic",
                       "Iberian Atlantic",
                       "South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3",
        "gold2",
        "darkorchid3",
        "navyblue",
        "turquoise2",
        "green3") # same colors as in paper 1

# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3)
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

### Identify the candidate SNPs

**SNP loadings** in the ordination space (stored as `species` in the RDA object) are used to determine which SNPs are **candidates for local adaptation**. SNP loadings are extracted from the significant constrained axes. Second, we use histograms of the loadings on each RDA axis to look at their (relatively normal) distributions. 

<span style="color: gray;">"SNPs loadings at the center of the distribution are not showing a relationship with the environmental predictors; those loading in the tails are, and are more likely to be under selection as a function of those predictors (or some other predictor correlated with them)."</span>

```{r LoadingsSnpsRDAcorrectionGPsAvgWater,fig.width=16,fig.height=4}
par(mfrow=c(1,3))
load.correctiongp.rda <- scores(correctiongp.rda, choices=c(1:7), display="species")  # Species scores for the seven constrained axes (all significant)
hist(load.correctiongp.rda[,1], main="Loadings on RDA1",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA2",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA3",xlab="",ylab="") 
hist(load.correctiongp.rda[,1], main="Loadings on RDA4",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA5",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA6",xlab="",ylab="") 
hist(load.correctiongp.rda[,3], main="Loadings on RDA7",xlab="",ylab="Frequency") 
```

Here is a function <span style="color: gray;">"to identify SNPs that load in the tails of these distributions. We’ll start with a 3 standard deviation cutoff (two-tailed p-value = 0.0027). As with all cutoffs, this can be modified to reflect the goals of the analysis and our tolerance for true positives vs. false positives. For example, if you needed to be very conservative and only identify those loci under very strong selection (i.e., minimize false positive rates), you could increase the number of standard deviations to 3.5 (two-tailed p-value = 0.0005). This would also increase the false negative rate. If you were less concerned with false positives, and more concerned with identifying as many potential candidate loci as possible (including those that may be under weaker selection), you might choose a 2.5 standard deviation cutoff (two-tailed p-value = 0.012)."</span>

Santi: "I would stick to 3 standard deviation cutoff, it seems a reasonable number to me."

> <span style="color: red;">In the article, we use a 3 standard deviation cutoff (two-tailed p-value = 0.0027) to identify SNPs that load in the tails of these distributions.</span>

```{r FunctionIdentifySNPsAvgWater}
# x is the vector of loadings and z is the number of standard deviations to use:
outliers <- function(x,z){
  lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading     
  x[x < lims[1] | x > lims[2]]               # locus names in these tails
}
```

<span style="color: gray;">"Now let’s apply it to each significant constrained axis:"</span>

```{r ApplyFunctionSigniConstrainedAxisAvgWater}
cand1 <- outliers(load.correctiongp.rda[,1],3) # 52 candidate SNPs on axis 1
cand2 <- outliers(load.correctiongp.rda[,2],3) # 19 candidate SNPs on axis 2
cand3 <- outliers(load.correctiongp.rda[,3],3) # 27 candidate SNPs on axis 3
cand4 <- outliers(load.correctiongp.rda[,4],3) # 27 candidate SNPs on axis 4
cand5 <- outliers(load.correctiongp.rda[,5],3) # 19 candidate SNPs on axis 5
cand6 <- outliers(load.correctiongp.rda[,6],3) # 18 candidate SNPs on axis 6
cand7 <- outliers(load.correctiongp.rda[,7],3) # 26 candidate SNPs on axis 7

ncand <- length(cand1) + length(cand2) + length(cand3) + length(cand4) + length(cand5) + length(cand6) + length(cand7)
ncand
```
> <span style="color: red;">189 candidates SNPs in total.</span>


Let's build a data frame with the axis, SNP name, loading, & correlation with each predictor:

```{r DFRDAcorrectionGPsAvgWater}
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
cand3 <- cbind.data.frame(rep(3,times=length(cand3)), names(cand3), unname(cand3))
cand4 <- cbind.data.frame(rep(4,times=length(cand4)), names(cand4), unname(cand4))
cand5 <- cbind.data.frame(rep(5,times=length(cand5)), names(cand5), unname(cand5))
cand6 <- cbind.data.frame(rep(6,times=length(cand6)), names(cand6), unname(cand6))
cand7 <- cbind.data.frame(rep(7,times=length(cand7)), names(cand7), unname(cand7))

colnames(cand1) <- colnames(cand2) <- colnames(cand3) <- colnames(cand4) <- colnames(cand5) <- colnames(cand6) <- colnames(cand7) <- c("axis","snp","loading")

cand <- rbind(cand1, cand2, cand3,cand4,cand5,cand6,cand7)
cand$snp <- as.character(cand$snp)
```

<span style="color: gray;">"Let’s add in the correlations of each candidate SNP with the eight environmental predictors:"</span>

```{r CorrelationPredictorsRDAcorrectionGPsAvgWater}
foo <- matrix(nrow=(ncand), ncol=length(select.var.AvgWater))
colnames(foo) <- select.var.AvgWater

for (i in 1:length(cand$snp)) {
  nam <- cand[i,2]
  snp.gen <- gen.imp[,nam]
  foo[i,] <- apply(env[,select.var.AvgWater],2,function(x) cor(x,snp.gen))
}

cand <- cbind.data.frame(cand,foo)  
head(cand) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = F)
```

Now we have a data frame of 189 candidate SNPs and their correlation with our 7 environmental predictors.



### Removing the duplicates

<span style="color: gray;">"We’ll start off by looking for duplicate detections. These are SNPs that are identified as candidates on more than one RDA axis."</span>

```{r DuplicatesRDAcorrectionGPsAvgWater}
length(cand$snp[duplicated(cand$snp)])  # 4 duplicate detections
cand <- cand[!duplicated(cand$snp),] # remove duplicate detections
nrow(cand)
```

> 4 duplicates, 185 remaining candidate SNPs.

```{r SaveCandidateSNPsAvgWater}
saveRDS(cand,file=paste0("outputs/CandidateSNPs/rda/",nrow(cand),"CandSNPsRDA_AvgWater.rds"))
```

We can calculate the genomic offset of this set of SNPs and see whether it is different from that of the other SNPs.

### Main predictor for each SNP

Which of the predictors each candidate SNP is most strongly correlated with?

```{r WhichPredictorsMostCorrCandidatesRDAcorrectionGPsAvgWater}
for (i in 1:length(cand$snp)) {
  bar <- cand[i,]
  cand[i,(3+length(select.var.AvgWater)+1)] <- names(which.max(abs(bar[4:(3+length(select.var.AvgWater))]))) # gives the variable
  cand[i,(3+length(select.var.AvgWater)+2)] <- max(abs(bar[4:(3+length(select.var.AvgWater))]))              # gives the correlation
}

colnames(cand)[(3+length(select.var.AvgWater)+1)] <- "predictor"
colnames(cand)[(3+length(select.var.AvgWater)+2)] <- "correlation"

table(cand$predictor) 
```

Lots of SNPs are mainly associated with `bio2` describing the continentality (mean diurnal temperature range). A lot are also mainly associated with precipitation-related variables (`bio12`, `bio14` and `water_top`).

<span style="color: gray;">"Note that, in some cases, correlations may be strong for multiple variables (depending on collinearity among predictors). It may be useful to consider how candidate SNPs are correlated with multiple predictors. We could, for example, look at the cand object and investigate correlations with predictors other than the predictor with the highest correlation coefficient. However, for this analysis we will focus on the strongest correlations of each SNP with one predictor."</span>


### Plot the SNPs

<span style="color: gray;">"Let’s look at RDA plots again, but this time focus in on the SNPs in the ordination space. We’ll color code the SNPs based on the predictor variable that they are most strongly correlated with."</span>

```{r PrepPlotSNPsRDAcorrectionGPsAvgWater}
sel <- cand$snp
predictor <- cand$predictor
predictor[predictor=="depth_roots"] <- '#1f78b4'
predictor[predictor=="bio12"] <- '#a6cee3'
predictor[predictor=="bio2"] <- '#6a3d9a'
predictor[predictor=="bio14"] <- '#e31a1c'
predictor[predictor=="bio1"] <- '#33a02c'
predictor[predictor=="water_top"] <- '#ffff33'
predictor[predictor=="TRI"] <- '#fb9a99'
#predictor[predictor==""] <- '#b2df8a'

# color by predictor:
col.pred <- rownames(correctiongp.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- predictor[i]
}

col.pred[grep("SNP",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99')
```

```{r PlotSNPsRDAcorrectionGPsAvgWater, fig.height=8,fig.width=8}
# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("topleft", legend=select.var.AvgWater, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("bottomright", legend=select.var.AvgWater, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)
```

**Comments from Santi:**

**- "Notice that when correcting using ancestry, the eigenvalues are more similar, meaning that there is not one that is much higher than the others, as in the case of runs not correcting by pop structure."**

**- "SNPs are still quite spread, i.e. not so close from the variable axes, which probably means weak selection or correlation with more than one factor."**



### Drought-associated candidates

> We are going to subset the SNPs associated with the precipitation of the driest month (`bio14`). This set of SNPs will then be used in the validation part: the "drought-resistant" alleles of these SNPs are expected to increase in frequency after the selection event in Caceres. 

We will refer to these SNPs as the drought-associated candidates (`dacand`).

We arbitrarily choose the threshold of $abs(\rho)>0.1$ with $\rho$ corresponding to the correlation coefficient of the candidate SNPs with the precipitation of the driest month (`bio14`).

```{r SubsetDroughtAssociatedCandidatesAvgWater}
dacand <- cand[abs(cand$bio14)>0.1,]
nrow(dacand)
nrow(dacand[abs(dacand$bio14)>0.3,])
```

> There are 125 drought-associated candidate SNPs with a coeff higher than 0.1 and 21 with a beta coeff higher than 0.3.


```{r PrepPlotDaCandSNPsRDAcorrectionGPsAvgWater}
sel <- dacand$snp
predictor <- rep('#e31a1c',length(sel))

# color by predictor:
col.pred <- rownames(correctiongp.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- predictor[i]
}

col.pred[grep("SNP",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- '#e31a1c'
```

```{r PlotDACandSNPsRDAcorrectionGPsAvgWater, fig.height=8,fig.width=8}
# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("topleft", legend="Drought-associated candidates", bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topleft", legend="Drought-associated candidates", bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)
```

```{r SaveDaCandidateSNPsAvgWater}
saveRDS(dacand,file=paste0("outputs/CandidateSNPs/rda/",nrow(dacand),"DaCandSNPsRDA.rds"))
```

### Continentality-associated candidates

> We are going to subset the SNPs associated with the mean diurnal temperature range (`bio2`) to compare with the outputs from <span style="font-variant:small-caps;">BayPass</span>. In the <span style="font-variant:small-caps;">BayPass</span> analyses, only SNPs associated with `bio2` show BF > 20dB. 

We will refer to these SNPs as the continentality-associated candidates (`cacand`).

We arbitrarily choose the threshold of $abs(\rho)>0.1$ with $\rho$ corresponding to the correlation coefficient of the candidate SNPs with the mean diurnal temperature range (`bio2`).

```{r SubsetContinentalityAssociatedCandidatesAvgWater}
cacand <- cand[abs(cand$bio2)>0.1,]
nrow(cacand)
nrow(cacand[abs(cacand$bio2)>0.3,])
```

> There are 118 drought-associated candidate SNPs.

```{r PrepPlotCaCandSNPsRDAcorrectionGPsAvgWater}
sel <- cacand$snp
predictor <- rep('#6a3d9a',length(sel))

# color by predictor:
col.pred <- rownames(correctiongp.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- predictor[i]
}

col.pred[grep("SNP",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- '#6a3d9a'
```

```{r PlotCACandSNPsRDAcorrectionGPsAvgWater, fig.height=8,fig.width=8}
# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("topleft", legend="Continentality-associated candidates", bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topleft", legend="Continentality-associated candidates", bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)
```

```{r SaveCaCandidateSNPsAvgWater}
saveRDS(dacand,file=paste0("outputs/CandidateSNPs/rda/",nrow(dacand),"CaCandSNPsRDA.rds"))
```

### Sum-up candidates

```{r SumUpCandidateNumberAvgWater}
DF <- data.frame(threshold=c(0.1,0.3), 
                 bio1=c(nrow(cand[abs(cand$bio1)>0.1,]),
                        nrow(cand[abs(cand$bio1)>0.3,])),
                 bio2=c(nrow(cand[abs(cand$bio2)>0.1,]),
                        nrow(cand[abs(cand$bio2)>0.3,])),
                 bio12=c(nrow(cand[abs(cand$bio12)>0.1,]),
                        nrow(cand[abs(cand$bio12)>0.3,])),
                 bio14=c(nrow(cand[abs(cand$bio14)>0.1,]),
                        nrow(cand[abs(cand$bio14)>0.3,])),
                 water_top=c(nrow(cand[abs(cand$water_top)>0.1,]),
                        nrow(cand[abs(cand$water_top)>0.3,])),
                 depth_roots=c(nrow(cand[abs(cand$depth_roots)>0.1,]),
                        nrow(cand[abs(cand$depth_roots)>0.3,])),
                 TRI=c(nrow(cand[abs(cand$TRI)>0.1,]),
                        nrow(cand[abs(cand$TRI)>0.3,])))
DF %>% 
  kable() %>%  
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = F) %>%
  column_spec(1, bold = T)
```

# Set AvgSand 

## RDA corrected by population structure with the ancestry coefficients

### run the RDA

```{r RDAncorrectionGPsAvgSand}
correctiongp.rda <- rda(gen.imp ~ bio1 + bio2 + bio12 + bio14 + sand_top + depth_roots + TRI + Condition(Q1 + Q2 + Q3 + Q4 + Q4 + Q5), data=env[,c(select.var.AvgSand,paste0(rep("Q",5),1:5))], scale=T)
correctiongp.rda
RsquareAdj(correctiongp.rda)
summary(eigenvals(correctiongp.rda, model = "constrained"))
screeplot(correctiongp.rda)
```

```{r RDAcorrectionGPsSigniFullAvgSand, cache=T}
signif.full <- anova.cca(correctiongp.rda, parallel=getOption("mc.cores")) # default is permutation=999
signif.full
```

```{r RDAcorrectionGPsSigniAxisAvgSand, cache=T}
signif.axis <- vegan::anova.cca(correctiongp.rda,by="axis", parallel=getOption("mc.cores"))
signif.axis
```

> All axes are significant! 

```{r RDAcorrectionGPsVIFAvgSand}
vif.cca(correctiongp.rda)
```

#### plot the RDA

```{r PlotRDAcorrectionGPsbasePlotsAvgSand, fig.height=6,fig.width=8}
plot(correctiongp.rda, scaling=3)          # default is axes 1 and 2
plot(correctiongp.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

```{r PlotRDAcorrectionGPsAvgSand, fig.height=10,fig.width=10}
levels(env$maxgp) <- c("Northern Africa",
                       "Corsica",
                       "Central Spain",
                       "French Atlantic",
                       "Iberian Atlantic",
                       "South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3",
        "gold2",
        "darkorchid3",
        "navyblue",
        "turquoise2",
        "green3") # same colors as in paper 1

# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3)
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

#### Identify the candidate SNPs

```{r LoadingsSnpsRDAcorrectionGPsAvgSand,fig.width=16,fig.height=4}
par(mfrow=c(1,3))
load.correctiongp.rda <- scores(correctiongp.rda, choices=c(1:7), display="species")  # Species scores for the seven constrained axes (all significant)
hist(load.correctiongp.rda[,1], main="Loadings on RDA1",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA2",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA3",xlab="",ylab="") 
hist(load.correctiongp.rda[,1], main="Loadings on RDA4",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA5",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA6",xlab="",ylab="") 
hist(load.correctiongp.rda[,3], main="Loadings on RDA7",xlab="",ylab="Frequency") 
```

```{r ApplyFunctionSigniConstrainedAxisAvgSand}
cand1 <- outliers(load.correctiongp.rda[,1],3) # 52 candidate SNPs on axis 1
cand2 <- outliers(load.correctiongp.rda[,2],3) # 19 candidate SNPs on axis 2
cand3 <- outliers(load.correctiongp.rda[,3],3) # 27 candidate SNPs on axis 3
cand4 <- outliers(load.correctiongp.rda[,4],3) # 27 candidate SNPs on axis 4
cand5 <- outliers(load.correctiongp.rda[,5],3) # 19 candidate SNPs on axis 5
cand6 <- outliers(load.correctiongp.rda[,6],3) # 18 candidate SNPs on axis 6
cand7 <- outliers(load.correctiongp.rda[,7],3) # 26 candidate SNPs on axis 7

ncand <- length(cand1) + length(cand2) + length(cand3) + length(cand4) + length(cand5) + length(cand6) + length(cand7)
ncand
```

> <span style="color: red;">180 candidates SNPs in total.</span>

```{r DFRDAcorrectionGPsAvgSand}
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
cand3 <- cbind.data.frame(rep(3,times=length(cand3)), names(cand3), unname(cand3))
cand4 <- cbind.data.frame(rep(4,times=length(cand4)), names(cand4), unname(cand4))
cand5 <- cbind.data.frame(rep(5,times=length(cand5)), names(cand5), unname(cand5))
cand6 <- cbind.data.frame(rep(6,times=length(cand6)), names(cand6), unname(cand6))
cand7 <- cbind.data.frame(rep(7,times=length(cand7)), names(cand7), unname(cand7))

colnames(cand1) <- colnames(cand2) <- colnames(cand3) <- colnames(cand4) <- colnames(cand5) <- colnames(cand6) <- colnames(cand7) <- c("axis","snp","loading")

cand <- rbind(cand1, cand2, cand3,cand4,cand5,cand6,cand7)
cand$snp <- as.character(cand$snp)
```

```{r CorrelationPredictorsRDAcorrectionGPsAvgSand}
foo <- matrix(nrow=(ncand), ncol=length(select.var.AvgSand))
colnames(foo) <- select.var.AvgSand

for (i in 1:length(cand$snp)) {
  nam <- cand[i,2]
  snp.gen <- gen.imp[,nam]
  foo[i,] <- apply(env[,select.var.AvgSand],2,function(x) cor(x,snp.gen))
}

cand <- cbind.data.frame(cand,foo)  
head(cand) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = F)
```


#### Removing the duplicates

```{r DuplicatesRDAcorrectionGPsAvgSand}
length(cand$snp[duplicated(cand$snp)])  # 4 duplicate detections
cand <- cand[!duplicated(cand$snp),] # remove duplicate detections
nrow(cand)
```

> 3 duplicates, 177 remaining candidate SNPs.

```{r SaveCandidateSNPsAvgSand}
saveRDS(cand,file=paste0("outputs/CandidateSNPs/rda/",nrow(cand),"CandSNPsRDA_AvgSand.rds"))
```

#### Main predictor for each SNP

```{r WhichPredictorsMostCorrCandidatesRDAcorrectionGPsAvgSand}
for (i in 1:length(cand$snp)) {
  bar <- cand[i,]
  cand[i,(3+length(select.var.AvgSand)+1)] <- names(which.max(abs(bar[4:(3+length(select.var.AvgSand))]))) # gives the variable
  cand[i,(3+length(select.var.AvgSand)+2)] <- max(abs(bar[4:(3+length(select.var.AvgSand))]))              # gives the correlation
}

colnames(cand)[(3+length(select.var.AvgSand)+1)] <- "predictor"
colnames(cand)[(3+length(select.var.AvgSand)+2)] <- "correlation"

table(cand$predictor) 
```

#### Plot the SNPs

```{r PrepPlotSNPsRDAcorrectionGPsAvgSand}
sel <- cand$snp
predictor <- cand$predictor
predictor[predictor=="depth_roots"] <- '#1f78b4'
predictor[predictor=="bio12"] <- '#a6cee3'
predictor[predictor=="bio2"] <- '#6a3d9a'
predictor[predictor=="bio14"] <- '#e31a1c'
predictor[predictor=="bio1"] <- '#33a02c'
predictor[predictor=="sand_top"] <- '#ffff33'
predictor[predictor=="TRI"] <- '#fb9a99'

# color by predictor:
col.pred <- rownames(correctiongp.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- predictor[i]
}

col.pred[grep("SNP",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99')
```

```{r PlotSNPsRDAcorrectionGPsAvgSand, fig.height=8,fig.width=8}
# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("topleft", legend=select.var.AvgSand, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("bottomright", legend=select.var.AvgSand, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)
```

# Set ExtSand 

## RDA corrected by population structure with the ancestry coefficients

### run the RDA

```{r RDAncorrectionGPsExtSand}
correctiongp.rda <- rda(gen.imp ~ bio5 + bio6 + bio13 + bio14 + sand_top + depth_roots + TRI + Condition(Q1 + Q2 + Q3 + Q4 + Q4 + Q5), data=env[,c(select.var.ExtSand,paste0(rep("Q",5),1:5))], scale=T)
correctiongp.rda
RsquareAdj(correctiongp.rda)
summary(eigenvals(correctiongp.rda, model = "constrained"))
screeplot(correctiongp.rda)
```

```{r RDAcorrectionGPsSigniFullExtSand, cache=T}
signif.full <- anova.cca(correctiongp.rda, parallel=getOption("mc.cores")) # default is permutation=999
signif.full
```

```{r RDAcorrectionGPsSigniAxisExtSand, cache=T}
signif.axis <- vegan::anova.cca(correctiongp.rda,by="axis", parallel=getOption("mc.cores"))
signif.axis
```

> All axes are significant! 

```{r RDAcorrectionGPsVIFExtSand}
vif.cca(correctiongp.rda)
```

#### plot the RDA

```{r PlotRDAcorrectionGPsbasePlotsExtSand, fig.height=6,fig.width=8}
plot(correctiongp.rda, scaling=3)          # default is axes 1 and 2
plot(correctiongp.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

```{r PlotRDAcorrectionGPsExtSand, fig.height=10,fig.width=10}
levels(env$maxgp) <- c("Northern Africa",
                       "Corsica",
                       "Central Spain",
                       "French Atlantic",
                       "Iberian Atlantic",
                       "South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3",
        "gold2",
        "darkorchid3",
        "navyblue",
        "turquoise2",
        "green3") # same colors as in paper 1

# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3)
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

#### Identify the candidate SNPs

```{r LoadingsSnpsRDAcorrectionGPsExtSand,fig.width=16,fig.height=4}
par(mfrow=c(1,3))
load.correctiongp.rda <- scores(correctiongp.rda, choices=c(1:7), display="species")  # Species scores for the seven constrained axes (all significant)
hist(load.correctiongp.rda[,1], main="Loadings on RDA1",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA2",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA3",xlab="",ylab="") 
hist(load.correctiongp.rda[,1], main="Loadings on RDA4",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA5",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA6",xlab="",ylab="") 
hist(load.correctiongp.rda[,3], main="Loadings on RDA7",xlab="",ylab="Frequency") 
```

```{r ApplyFunctionSigniConstrainedAxisExtSand}
cand1 <- outliers(load.correctiongp.rda[,1],3) # 52 candidate SNPs on axis 1
cand2 <- outliers(load.correctiongp.rda[,2],3) # 19 candidate SNPs on axis 2
cand3 <- outliers(load.correctiongp.rda[,3],3) # 27 candidate SNPs on axis 3
cand4 <- outliers(load.correctiongp.rda[,4],3) # 27 candidate SNPs on axis 4
cand5 <- outliers(load.correctiongp.rda[,5],3) # 19 candidate SNPs on axis 5
cand6 <- outliers(load.correctiongp.rda[,6],3) # 18 candidate SNPs on axis 6
cand7 <- outliers(load.correctiongp.rda[,7],3) # 26 candidate SNPs on axis 7

ncand <- length(cand1) + length(cand2) + length(cand3) + length(cand4) + length(cand5) + length(cand6) + length(cand7)
ncand
```

> <span style="color: red;">174 candidates SNPs in total.</span>

```{r DFRDAcorrectionGPsExtSand}
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
cand3 <- cbind.data.frame(rep(3,times=length(cand3)), names(cand3), unname(cand3))
cand4 <- cbind.data.frame(rep(4,times=length(cand4)), names(cand4), unname(cand4))
cand5 <- cbind.data.frame(rep(5,times=length(cand5)), names(cand5), unname(cand5))
cand6 <- cbind.data.frame(rep(6,times=length(cand6)), names(cand6), unname(cand6))
cand7 <- cbind.data.frame(rep(7,times=length(cand7)), names(cand7), unname(cand7))

colnames(cand1) <- colnames(cand2) <- colnames(cand3) <- colnames(cand4) <- colnames(cand5) <- colnames(cand6) <- colnames(cand7) <- c("axis","snp","loading")

cand <- rbind(cand1, cand2, cand3,cand4,cand5,cand6,cand7)
cand$snp <- as.character(cand$snp)
```

```{r CorrelationPredictorsRDAcorrectionGPsExtSand}
foo <- matrix(nrow=(ncand), ncol=length(select.var.ExtSand))
colnames(foo) <- select.var.ExtSand

for (i in 1:length(cand$snp)) {
  nam <- cand[i,2]
  snp.gen <- gen.imp[,nam]
  foo[i,] <- apply(env[,select.var.ExtSand],2,function(x) cor(x,snp.gen))
}

cand <- cbind.data.frame(cand,foo)  
head(cand) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = F)
```


#### Removing the duplicates

```{r DuplicatesRDAcorrectionGPsExtSand}
length(cand$snp[duplicated(cand$snp)])  # 4 duplicate detections
cand <- cand[!duplicated(cand$snp),] # remove duplicate detections
nrow(cand)
```

> 1 duplicate, 173 remaining candidate SNPs.

```{r SaveCandidateSNPsExtSand}
saveRDS(cand,file=paste0("outputs/CandidateSNPs/rda/",nrow(cand),"CandSNPsRDA_ExtSand.rds"))
```

#### Main predictor for each SNP

```{r WhichPredictorsMostCorrCandidatesRDAcorrectionGPsExtSand}
for (i in 1:length(cand$snp)) {
  bar <- cand[i,]
  cand[i,(3+length(select.var.ExtSand)+1)] <- names(which.max(abs(bar[4:(3+length(select.var.ExtSand))]))) # gives the variable
  cand[i,(3+length(select.var.ExtSand)+2)] <- max(abs(bar[4:(3+length(select.var.ExtSand))]))              # gives the correlation
}

colnames(cand)[(3+length(select.var.ExtSand)+1)] <- "predictor"
colnames(cand)[(3+length(select.var.ExtSand)+2)] <- "correlation"

table(cand$predictor) 
```

#### Plot the SNPs

```{r PrepPlotSNPsRDAcorrectionGPsExtSand}
sel <- cand$snp
predictor <- cand$predictor
predictor[predictor=="depth_roots"] <- '#1f78b4'
predictor[predictor=="bio13"] <- '#a6cee3'
predictor[predictor=="bio5"] <- '#6a3d9a'
predictor[predictor=="bio14"] <- '#e31a1c'
predictor[predictor=="bio6"] <- '#33a02c'
predictor[predictor=="sand_top"] <- '#ffff33'
predictor[predictor=="TRI"] <- '#fb9a99'

# color by predictor:
col.pred <- rownames(correctiongp.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- predictor[i]
}

col.pred[grep("SNP",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99')
```

```{r PlotSNPsRDAcorrectionGPsExtSand, fig.height=8,fig.width=8}
# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("topleft", legend=select.var.ExtSand, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("bottomright", legend=select.var.ExtSand, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)
```

# Set ExtWater 

## RDA corrected by population structure with the ancestry coefficients

### run the RDA

```{r RDAncorrectionGPsExtWater}
correctiongp.rda <- rda(gen.imp ~ bio5 + bio6 + bio13 + bio14 + water_top + depth_roots + TRI + Condition(Q1 + Q2 + Q3 + Q4 + Q4 + Q5), data=env[,c(select.var.ExtWater,paste0(rep("Q",5),1:5))], scale=T)
correctiongp.rda
RsquareAdj(correctiongp.rda)
summary(eigenvals(correctiongp.rda, model = "constrained"))
screeplot(correctiongp.rda)
```

```{r RDAcorrectionGPsSigniFullExtWater, cache=T}
signif.full <- anova.cca(correctiongp.rda, parallel=getOption("mc.cores")) # default is permutation=999
signif.full
```

```{r RDAcorrectionGPsSigniAxisExtWater, cache=T}
signif.axis <- vegan::anova.cca(correctiongp.rda,by="axis", parallel=getOption("mc.cores"))
signif.axis
```

> All axes are significant! 

```{r RDAcorrectionGPsVIFExtWater}
vif.cca(correctiongp.rda)
```

#### plot the RDA

```{r PlotRDAcorrectionGPsbasePlotsExtWater, fig.height=6,fig.width=8}
plot(correctiongp.rda, scaling=3)          # default is axes 1 and 2
plot(correctiongp.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

```{r PlotRDAcorrectionGPsExtWater, fig.height=10,fig.width=10}
levels(env$maxgp) <- c("Northern Africa",
                       "Corsica",
                       "Central Spain",
                       "French Atlantic",
                       "Iberian Atlantic",
                       "South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3",
        "gold2",
        "darkorchid3",
        "navyblue",
        "turquoise2",
        "green3") # same colors as in paper 1

# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3)
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

#### Identify the candidate SNPs

```{r LoadingsSnpsRDAcorrectionGPsExtWater,fig.width=16,fig.height=4}
par(mfrow=c(1,3))
load.correctiongp.rda <- scores(correctiongp.rda, choices=c(1:7), display="species")  # Species scores for the seven constrained axes (all significant)
hist(load.correctiongp.rda[,1], main="Loadings on RDA1",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA2",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA3",xlab="",ylab="") 
hist(load.correctiongp.rda[,1], main="Loadings on RDA4",xlab="",ylab="Frequency")
hist(load.correctiongp.rda[,2], main="Loadings on RDA5",xlab="",ylab="")
hist(load.correctiongp.rda[,3], main="Loadings on RDA6",xlab="",ylab="") 
hist(load.correctiongp.rda[,3], main="Loadings on RDA7",xlab="",ylab="Frequency") 
```

```{r ApplyFunctionSigniConstrainedAxisExtWater}
cand1 <- outliers(load.correctiongp.rda[,1],3) # 52 candidate SNPs on axis 1
cand2 <- outliers(load.correctiongp.rda[,2],3) # 19 candidate SNPs on axis 2
cand3 <- outliers(load.correctiongp.rda[,3],3) # 27 candidate SNPs on axis 3
cand4 <- outliers(load.correctiongp.rda[,4],3) # 27 candidate SNPs on axis 4
cand5 <- outliers(load.correctiongp.rda[,5],3) # 19 candidate SNPs on axis 5
cand6 <- outliers(load.correctiongp.rda[,6],3) # 18 candidate SNPs on axis 6
cand7 <- outliers(load.correctiongp.rda[,7],3) # 26 candidate SNPs on axis 7

ncand <- length(cand1) + length(cand2) + length(cand3) + length(cand4) + length(cand5) + length(cand6) + length(cand7)
ncand
```

> <span style="color: red;">187 candidates SNPs in total.</span>

```{r DFRDAcorrectionGPsExtWater}
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
cand3 <- cbind.data.frame(rep(3,times=length(cand3)), names(cand3), unname(cand3))
cand4 <- cbind.data.frame(rep(4,times=length(cand4)), names(cand4), unname(cand4))
cand5 <- cbind.data.frame(rep(5,times=length(cand5)), names(cand5), unname(cand5))
cand6 <- cbind.data.frame(rep(6,times=length(cand6)), names(cand6), unname(cand6))
cand7 <- cbind.data.frame(rep(7,times=length(cand7)), names(cand7), unname(cand7))

colnames(cand1) <- colnames(cand2) <- colnames(cand3) <- colnames(cand4) <- colnames(cand5) <- colnames(cand6) <- colnames(cand7) <- c("axis","snp","loading")

cand <- rbind(cand1, cand2, cand3,cand4,cand5,cand6,cand7)
cand$snp <- as.character(cand$snp)
```

```{r CorrelationPredictorsRDAcorrectionGPsExtWater}
foo <- matrix(nrow=(ncand), ncol=length(select.var.ExtWater))
colnames(foo) <- select.var.ExtWater

for (i in 1:length(cand$snp)) {
  nam <- cand[i,2]
  snp.gen <- gen.imp[,nam]
  foo[i,] <- apply(env[,select.var.ExtWater],2,function(x) cor(x,snp.gen))
}

cand <- cbind.data.frame(cand,foo)  
head(cand) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("hover", "condensed"), full_width = F)
```


#### Removing the duplicates

```{r DuplicatesRDAcorrectionGPsExtWater}
length(cand$snp[duplicated(cand$snp)])  # 4 duplicate detections
cand <- cand[!duplicated(cand$snp),] # remove duplicate detections
nrow(cand)
```

> 4 duplicate, 183 remaining candidate SNPs.

```{r SaveCandidateSNPsExtWater}
saveRDS(cand,file=paste0("outputs/CandidateSNPs/rda/",nrow(cand),"CandSNPsRDA_ExtWater.rds"))
```

#### Main predictor for each SNP

```{r WhichPredictorsMostCorrCandidatesRDAcorrectionGPsExtWater}
for (i in 1:length(cand$snp)) {
  bar <- cand[i,]
  cand[i,(3+length(select.var.ExtWater)+1)] <- names(which.max(abs(bar[4:(3+length(select.var.ExtWater))]))) # gives the variable
  cand[i,(3+length(select.var.ExtWater)+2)] <- max(abs(bar[4:(3+length(select.var.ExtWater))]))              # gives the correlation
}

colnames(cand)[(3+length(select.var.ExtWater)+1)] <- "predictor"
colnames(cand)[(3+length(select.var.ExtWater)+2)] <- "correlation"

table(cand$predictor) 
```

#### Plot the SNPs

```{r PrepPlotSNPsRDAcorrectionGPsExtWater}
sel <- cand$snp
predictor <- cand$predictor
predictor[predictor=="depth_roots"] <- '#1f78b4'
predictor[predictor=="bio13"] <- '#a6cee3'
predictor[predictor=="bio5"] <- '#6a3d9a'
predictor[predictor=="bio14"] <- '#e31a1c'
predictor[predictor=="bio6"] <- '#33a02c'
predictor[predictor=="water_top"] <- '#ffff33'
predictor[predictor=="TRI"] <- '#fb9a99'

# color by predictor:
col.pred <- rownames(correctiongp.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- predictor[i]
}

col.pred[grep("SNP",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99')
```

```{r PlotSNPsRDAcorrectionGPsExtWater, fig.height=8,fig.width=8}
# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("topleft", legend=select.var.ExtWater, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("bottomright", legend=select.var.ExtWater, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)
```



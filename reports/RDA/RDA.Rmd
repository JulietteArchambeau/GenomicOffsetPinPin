---
title: 'Multilocus genetic-environment association: Redundancy Analysis (RDA)'
author: "Juliette Archambeau"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    # code_fold: hide
    toc: true
    toc_depth: 4
    toc_float:
       collapsed: false
    number_sections: true
    highlight: textmate
---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<style type="text/css">
div.main-container {
  max-width: 2000px;
  margin-left: auto;
  margin-right: auto;
}
</style>


```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 5,fig.height = 4,cache=FALSE)
options(width = 300)
library(knitr)
library(vegan)  # to investigate correlations among predictors
library(psych)  # to run RDA
library(tidyverse)
library(adespatial) # to calculate the Moran eigen vectors
```

This script is based on [Forester et al. (2018)](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14584) and their [vignette](https://popgen.nescent.org/2018-03-27_RDA_GEA.html). All the <span style="color: gray;">quotes in gray</span> in the document come from this vignette.


Notes on **correction for population structure** from [Forester et al. (2018)](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14584).

In their paper, they investigate the effects of correction for **weak** population structure only. In their conclusion: "It is important to note that population structure was relatively low in these simulations. Results may differ for systems with strong population structure or metapopulation dynamics, where it can be important to correct for structure or combine detections with another GEA that accounts for structure."

# DATA

## Genomic data

```{r LoadGenotypeData}
# File with the genotype names (clone names)
geno_names <- read.delim2("../../data/ClonapinBlups523IndPiMASSJuly2019.txt", row.names=1)

# File with the genotype of each clone for each SNP
geno <- read.csv("../../data/5165snps523genotypesNA.txt", header=FALSE, row.names=1)

# Removing the first two columns with allele info (A,T, G or C)
geno <- geno[,3:dim(geno)[[2]]]

# Give the genotype name for each column of geno
colnames(geno) <- rownames(geno_names)

# Genotypes in rows, SNPs in columns
geno <- as.data.frame(t(geno))

geno[1:10,1:10]
```

There are 17,263 missing values (~6% of missing values). Like in the [vignette](https://popgen.nescent.org/2018-03-27_RDA_GEA.html), we impute the missing values using the most common genotype at each SNP across all individuals.

```{r NAs}
sum(is.na(geno)) # 17,263 missing values;  17263/(5165*523) = 0.006390639 => ~ 6% missing values

gen.imp <- apply(geno, 2, function(x) replace(x, is.na(x), as.numeric(names(which.max(table(x))))))
sum(is.na(gen.imp)) # No NAs
```


According to the [vignette](https://popgen.nescent.org/2018-03-27_RDA_GEA.html), other methods are possible: <span style="color: gray;">"We could also use this imputation approach within ecotypes (rather than across all individuals). Other promising imputation methods for species lacking a reference genome include: using ancestry values from `snmf` in the `LEA` package (Frichot & Francois 2015), using Random Forest (implemented for genomic data in the R package `grur`, Gosselin 2017), and the program LinkImpute (Money et al., 2015)."</span>

## Environmental and population structure data

```{r LoadEnvData,fig.height=10,fig.width=16}
env <- readRDS(file="../../data/AllDataPhenoClimSoil.RDS")
env <- env %>% select(clon,prov,contains("ude_prov"),contains("bio"),contains("top_prov"),"depth_roots_prov", paste0(rep("Q",6),1:6),max.Q)
colnames(env) <- c("genotype","prov",str_sub(grep("_prov",colnames(env),value=TRUE),1,-6),paste0(rep("Q",6),1:6),"maxgp")
env <- unique(env)
env <- env[!(env$prov=="ROD"),]

topo <- readRDS(file="../../data/Topography/DfTopoVarbyProv.rds")
topo <- topo %>% dplyr::select(prov,TRI_WGS84_90m_R) %>% 
                 dplyr::rename(TRI=TRI_WGS84_90m_R)
env <- merge(env,topo,by="prov")
env

env <- env[env$genotype %in% rownames(geno_names),]

select.env <- c("bio1","bio2","bio12","bio14","water_top","depth_roots","TRI")
pairs.panels(env[,select.env], scale=T)
pairs.panels(unique(env[,select.env]), scale=T)
```

Genotypes are in the same order in `env` and `gen.imp`.

```{r Order}
identical(rownames(gen.imp), env[,2])
```


# RDA not corrected by population structure

## run the RDA

<span style="color: gray;">"[...] we highly recommend Borcard et al. (2011) for details on the implementation and interpretation of RDA models and the objects created by vegan. RDA runs relatively quickly on most data sets, however on a very large data set it can take 15-20 minutes, depending on the computer.

Note: if your predictors include any factors, you’ll need to write out the formula in the rda call if you want to include a significance test of the constrained axis. Since we are not using any factors in this analysis, we can use the shorthand formula `gen.imp ~ .`"</span>


```{r RDAnocorrectionRun}
nocorrection.rda <- rda(gen.imp ~ ., data=env[,select.env], scale=T)
nocorrection.rda
```

<span style="color: gray;">"note that we will have as many constrained (“RDA”) axes as we have predictors in the model. All residual variance is then modeled by PCA (the unconstrained “PC” axes). The proportion of the variance explained by the environmental predictors is given under the “Proportion” column for “Constrained”; this is equivalent to the $\mathcal{R}^{2}$ of a multiple regression. Just like in multiple regression, this $\mathcal{R}^{2}$ will be biased and should be adjusted based on the number of predictors."</span>
That's why we calculate the adjusted $\mathcal{R}^{2}$ using the function `RsquaredAdj`, as below:

```{r RsquareAdjRDAnocorrection}
RsquareAdj(nocorrection.rda)
```

In our case, the constrained ordination explains about ??% of the variation. <span style="color: gray;">"this low explanatory power is not surprising given that we expect that most of the SNPs in our dataset will not show a relationship with the environmental predictors (e.g., most SNPs will be neutral)."</span>

<span style="color: gray;">"The eigenvalues for the constrained axes reflect the variance explained by each canonical axis, as shown by the function `summary(eignevals(..., model="constrained"))`."</span>

```{r SummaryEigneValsRDAnocorrection}
summary(eigenvals(nocorrection.rda, model = "constrained"))
```

<span style="color: gray;">"We can visualize this information using a screeplot of the canonical eigenvalues by calling `screeplot`:"</span>


```{r ScreeplotRDAnocorrection}
screeplot(nocorrection.rda)
```


<span style="color: gray;">"Here, we can see that the first ??? constrained axes explain most of the variance. **The screeplot provides an informal (and quick) way to determine how many constrained axes to include when we search for candidate SNPs (below)**. We could start by investigating RDA axes that explain the most variance (excluding those after the “drop off” point in the screeplot.)

Now let’s check our RDA model for significance using formal tests. We can assess both the full model and each constrained axis using F-statistics (Legendre et al, 2010). The null hypothesis is that no linear relationship exists between the SNP data and the environmental predictors. See ?anova.cca for more details and options."</span>


```{r RDAnocorrectionSigniFull, cache=T}
signif.full <- anova.cca(nocorrection.rda, parallel=getOption("mc.cores")) # default is permutation=999
signif.full
```

<span style="color: gray;">"The full model is significant, but that doesn’t tell us much. We can check each constrained axis for significance using the code below. For this test, each constrained axis is tested using all previous constrained axes as conditions. See `?anova.cca` and Legendre et al. (2010) for details. The purpose here is to determine which constrained axes we should investigate for candidate loci. [...] This analysis is time intensive."</span>

All the constrained axes are significant, which is a bit strange.

`anova.cca` "Setting by = "axis" will perform separate significance tests for each constrained axis. All previous constrained axes will be used as conditions (“partialled out”) and a test for the first constrained eigenvalues is performed (Legendre et al. 2011). You can stop permutation tests after exceeding a given significance level with argument cutoff to speed up calculations in large models."

```{r RDAnocorrectionSigniAxis, cache=T}
signif.axis <- anova.cca(nocorrection.rda, by="axis", parallel=getOption("mc.cores"))
signif.axis
```

<span style="color: gray;">"Finally, `vegan` has a simple function for checking Variance Inflation Factors for the predictor variables used in the model:"</span>

```{r RDAnocorrectionVIF}
vif.cca(nocorrection.rda)
```

<span style="color: gray;">"All values are below 10, and most are below 5, which indicates that multicollinearity among these predictors shouldn’t be a problem for the model."</span>

## plot the RDA

<span style="color: gray;">"We’ll start with simple triplots from `vegan`. Here we’ll use scaling=3 (also known as “symmetrical scaling”) for the ordination plots. This scales the SNP and individual scores by the square root of the eigenvalues. See Borcard et al. (2011) or the `vegan` help for more information on scaling in RDA plots."</span>

```{r PlotRDAnocorrectionbasePlots, fig.height=6,fig.width=6}
plot(nocorrection.rda, scaling=3)          # default is axes 1 and 2
plot(nocorrection.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

- <span style="color: red;">The SNPs are the red points in the center of each plot.</span>

- The genotypes are the black circles.

- <span style="color: blue;">The blue vectors are the environmental predictors.</span> 

<span style="color: gray;">"The relative arrangement of these items in the ordination space reflects their relationship with the ordination axes, which are linear combinations of the predictor variables."</span>

We are going to make some more informative plots: the **genotypes** points are colored based on the **main gene pool** the belong to.

```{r PlotRDAnocorrection, fig.height=8,fig.width=8}
levels(env$maxgp) <- c("Northern Africa","Corsica","Central Spain","French Atlantic","Iberian Atlantic","South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3") # same colors as in paper 1

# axes 1 & 2
plot(nocorrection.rda, type="n", scaling=3)
points(nocorrection.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(nocorrection.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(nocorrection.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)

# axes 1 & 3
plot(nocorrection.rda, type="n", scaling=3, choices=c(1,3))
points(nocorrection.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(nocorrection.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(nocorrection.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topleft", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

> We can clearly see here that the ordination space is driven by population structure. We have to correct RDA by population structure.

# RDA corrected by population structure

## Correction by Moran eigen's vectors

Here, we run a **partial RDA**, conditionned on distance-based MEMs (dbMEM spatial eigenfunctions) calculated from a geographic distance matrix with the function `dbmem` from the `adespatial` package. See section 2.7 in [Forester et al. (2018)](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14584).

Information on Moran eigenvectors: 

- https://cran.r-project.org/web/packages/adespatial/vignettes/tutorial.html

- http://biol09.biol.umontreal.ca/PLcourses/Spatial_eigenfunction_modelling.pdf

I have to verify if it is ok how I calculated the Moran eigenvectors here:

- Do I have to calculate them with one genotype per row or one prov per row? 

- How do I know which are the significant MEMs? 

- Here I use the distance-based Moran's eigenvector maps but there are many other possibilities given different values, e.g. PCNM (can be calculated with the function `pcnm` of the `vegan` package), the Moran’s Eigenvectors Maps (provided by the functions `scores.listw` or `mem` of the `adespatial` package. These two functions are exactly identical, both are kept for historical reasons and compatibility)


```{r MEMs}
# Calculate the distance-based MEM with one row per genotype
#mem <- env %>% select(latitude,longitude) %>% dbmem(MEM.autocor = c("positive"),store.listw = FALSE)
#env <- bind_cols(env,mem)

# Calculate the distance-based MEM with one row per prov
provs <- env %>% select(prov,latitude,longitude) %>% distinct()
mem <- provs %>% select(latitude,longitude) %>% dbmem(MEM.autocor = c("positive"),store.listw = FALSE)
mem <- bind_cols(provs,mem)
env <- merge(env,mem,by=c("prov","latitude","longitude"))
```

There are 4 MEMs with a positive autocorrelation (MEMs associated to positive eigenvalues). 

### run the RDA

```{r RDAncorrectionMEMs}
correctionmem.rda <- rda(gen.imp ~ bio1 + bio2 + bio12 + bio14 + water_top + depth_roots + TRI + Condition(MEM1 + MEM2 + MEM3 + MEM4),
                         data=env[,c(select.env,paste0(rep("MEM",4),1:4))],
                         scale=T)
# correctionmem.rda <- rda(X=gen.imp ,Y=env[,select.env], Z=mem,scale=T) # same
correctionmem.rda
RsquareAdj(correctionmem.rda)
summary(eigenvals(correctionmem.rda, model = "constrained"))
screeplot(correctionmem.rda)
```

### plot the RDA

```{r PlotRDAcorrectionMEMsbasePlots, fig.height=6,fig.width=6}
plot(correctionmem.rda, scaling=3)          # default is axes 1 and 2
plot(correctionmem.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

```{r PlotRDAcorrectionMEMs, fig.height=8,fig.width=8}
levels(env$maxgp) <- c("Northern Africa","Corsica","Central Spain","French Atlantic","Iberian Atlantic","South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3","gold2","darkorchid3","navyblue","turquoise2","green3") # same colors as in paper 1

# axes 1 & 2
plot(correctionmem.rda, type="n", scaling=3)
points(correctionmem.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(correctionmem.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(correctionmem.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctionmem.rda, type="n", scaling=3, choices=c(1,3))
points(correctionmem.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(correctionmem.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(correctionmem.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topleft", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

> We can see that the population structure is not well taken into account with the distance-based Moran's eigenvector maps.

## Correction by the ancestry coefficients


### run the RDA

```{r RDAncorrectionGPs}
correctiongp.rda <- rda(gen.imp ~ bio1 + bio2 + bio12 + bio14 + water_top + depth_roots + TRI + Condition(Q1 + Q2 + Q3 + Q4 + Q4 + Q5), data=env[,c(select.env,paste0(rep("Q",5),1:5))], scale=T)
# correctiongp.rda <- rda(X=gen.imp ,Y=env[,select.env], Z=env[,paste0(rep("Q",6),1:6)],scale=T)  # Same as the line beofre, but if I use this formulation, I can't use annova.cca by "axis".
correctiongp.rda
RsquareAdj(correctiongp.rda)
summary(eigenvals(correctiongp.rda, model = "constrained"))
screeplot(correctiongp.rda)
```

```{r RDAcorrectionGPsSigniFull, cache=T}
signif.full <- anova.cca(correctiongp.rda, parallel=getOption("mc.cores")) # default is permutation=999
signif.full
```

```{r RDAcorrectionGPsSigniAxis, cache=T}
signif.axis <- vegan::anova.cca(correctiongp.rda,by="axis", parallel=getOption("mc.cores"))
signif.axis
```

All axis are aignificant! 

```{r RDAcorrectionGPsVIF}
vif.cca(correctiongp.rda)
```

### plot the RDA

```{r PlotRDAcorrectionGPsbasePlots, fig.height=6,fig.width=6}
plot(correctiongp.rda, scaling=3)          # default is axes 1 and 2
plot(correctiongp.rda, choices = c(1, 3), scaling=3)  # axes 1 and 3
```

```{r PlotRDAcorrectionGPs, fig.height=10,fig.width=10}
levels(env$maxgp) <- c("Northern Africa",
                       "Corsica",
                       "Central Spain",
                       "French Atlantic",
                       "Iberian Atlantic",
                       "South-eastern Spain")
GPs <- env$maxgp
bg <- c("orangered3",
        "gold2",
        "darkorchid3",
        "navyblue",
        "turquoise2",
        "green3") # same colors as in paper 1

# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3)
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3)           # the SNPs
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs]) # the genotypes
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)                           # the predictors
legend("bottomright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=20, cex=0.7, col="gray32", scaling=3, choices=c(1,3))
points(correctiongp.rda, display="sites", pch=21, cex=1.3, col="gray32", scaling=3, bg=bg[GPs], choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("topright", legend=levels(GPs), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)
```

### Identify the candidate SNPs

**SNP loadings** in the ordination space (stored as `species` in the RDA object) are used to determine which SNPs are **candidates for local adaptation**. SNP loadings are extracted from the ??? significant constrained axes. Second, we use histograms of the loadings on each RDA axis to look at their (relatively normal) distributions. 

<span style="color: gray;">"SNPs loadings at the center of the distribution are not showing a relationship with the environmental predictors; those loading in the tails are, and are more likely to be under selection as a function of those predictors (or some other predictor correlated with them)."</span>

```{r LoadingsSnpsRDAcorrectionGPs,fig.width=10}
par(mfrow=c(1,3))
load.correctiongp.rda <- scores(correctiongp.rda, choices=c(1:7), display="species")  # Species scores for the seven constrained axes (all significant)
hist(load.correctiongp.rda[,1], main="Loadings on RDA1")
hist(load.correctiongp.rda[,2], main="Loadings on RDA2")
hist(load.correctiongp.rda[,3], main="Loadings on RDA3") 
```

Here is a function <span style="color: gray;">"to identify SNPs that load in the tails of these distributions. We’ll start with a 3 standard deviation cutoff (two-tailed p-value = 0.0027). As with all cutoffs, this can be modified to reflect the goals of the analysis and our tolerance for true positives vs. false positives. For example, if you needed to be very conservative and only identify those loci under very strong selection (i.e., minimize false positive rates), you could increase the number of standard deviations to 3.5 (two-tailed p-value = 0.0005). This would also increase the false negative rate. If you were less concerned with false positives, and more concerned with identifying as many potential candidate loci as possible (including those that may be under weaker selection), you might choose a 2.5 standard deviation cutoff (two-tailed p-value = 0.012)."</span>

> To discuss with Santi and Marta here, which threshold do we choose?

```{r FunctionIdentifySNPs}
# x is the vector of loadings and z is the number of standard deviations to use:
outliers <- function(x,z){
  lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading     
  x[x < lims[1] | x > lims[2]]               # locus names in these tails
}
```

<span style="color: gray;">"Now let’s apply it to each significant constrained axis:"</span>

```{r ApplyFunctionSigniConstrainedAxis}
cand1 <- outliers(load.correctiongp.rda[,1],3) # 52 candidate SNPs on axis 1
cand2 <- outliers(load.correctiongp.rda[,2],3) # 19 candidate SNPs on axis 2
cand3 <- outliers(load.correctiongp.rda[,3],3) # 27 candidate SNPs on axis 3
cand4 <- outliers(load.correctiongp.rda[,4],3) # 27 candidate SNPs on axis 4
cand5 <- outliers(load.correctiongp.rda[,5],3) # 19 candidate SNPs on axis 5
cand6 <- outliers(load.correctiongp.rda[,6],3) # 18 candidate SNPs on axis 6
cand7 <- outliers(load.correctiongp.rda[,7],3) # 26 candidate SNPs on axis 7

ncand <- length(cand1) + length(cand2) + length(cand3) + length(cand4) + length(cand5) + length(cand6) + length(cand7)
ncand # 188 candidates SNPs in total !
```

Let's build a data frame with the axis, SNP name, loading, & correlation with each predictor:

```{r DFRDAcorrectionGPs}
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
cand3 <- cbind.data.frame(rep(3,times=length(cand3)), names(cand3), unname(cand3))
cand4 <- cbind.data.frame(rep(4,times=length(cand4)), names(cand4), unname(cand4))
cand5 <- cbind.data.frame(rep(5,times=length(cand5)), names(cand5), unname(cand5))
cand6 <- cbind.data.frame(rep(6,times=length(cand6)), names(cand6), unname(cand6))
cand7 <- cbind.data.frame(rep(7,times=length(cand7)), names(cand7), unname(cand7))

colnames(cand1) <- colnames(cand2) <- colnames(cand3) <- colnames(cand4) <- colnames(cand5) <- colnames(cand6) <- colnames(cand7) <- c("axis","snp","loading")

cand <- rbind(cand1, cand2, cand3,cand4,cand5,cand6,cand7)
cand$snp <- as.character(cand$snp)
```

<span style="color: gray;">"Let’s add in the correlations of each candidate SNP with the eight environmental predictors:"</span>

```{r CorrelationPredictorsRDAcorrectionGPs}
foo <- matrix(nrow=(ncand), ncol=length(select.env))  # 8 columns for 8 predictors
colnames(foo) <- select.env

for (i in 1:length(cand$snp)) {
  nam <- cand[i,2]
  snp.gen <- gen.imp[,nam]
  foo[i,] <- apply(env[,select.env],2,function(x) cor(x,snp.gen))
}

cand <- cbind.data.frame(cand,foo)  
head(cand)
```

Now we have a data frame of 188 candidate SNPs and their correlation with our 7 environmental predictors.


### Investigate the candidates

<span style="color: gray;">"We’ll start off by looking for duplicate detections. These are SNPs that are identified as candidates on more than one RDA axis."</span>

```{r DuplicatesRDAcorrectionGPs}
length(cand$snp[duplicated(cand$snp)])  # 5 duplicate detections
cand <- cand[!duplicated(cand$snp),] # remove duplicate detections
```

```{r SaveCandidateSNPs}
saveRDS(cand,file="../../outputs/CandidateSNPs/183SNPsRDA.rds")
```


Which of the predictors each candidate SNP is most strongly correlated with?

```{r WhichPredictorsMostCorrCandidatesRDAcorrectionGPs}
for (i in 1:length(cand$snp)) {
  bar <- cand[i,]
  cand[i,(3+length(select.env)+1)] <- names(which.max(abs(bar[4:(3+length(select.env))]))) # gives the variable
  cand[i,(3+length(select.env)+2)] <- max(abs(bar[4:(3+length(select.env))]))              # gives the correlation
}

colnames(cand)[(3+length(select.env)+1)] <- "predictor"
colnames(cand)[(3+length(select.env)+2)] <- "correlation"

table(cand$predictor) 
```

Lots of SNPs are associated with `bio2` describing the continentality (mean diurnal temperature range). A lot are also associated with precipitation-related variables (`bio12`, `bio14` and `water_top`).

<span style="color: gray;">"Note that, in some cases, correlations may be strong for multiple variables (depending on collinearity among predictors). It may be useful to consider how candidate SNPs are correlated with multiple predictors. We could, for example, look at the cand object and investigate correlations with predictors other than the predictor with the highest correlation coefficient. However, for this analysis we will focus on the strongest correlations of each SNP with one predictor."</span>


### Plot the SNPs

<span style="color: gray;">"Let’s look at RDA plots again, but this time focus in on the SNPs in the ordination space. We’ll color code the SNPs based on the predictor variable that they are most strongly correlated with."</span>

```{r PrepPlotSNPsRDAcorrectionGPs}
sel <- cand$snp
predictor <- cand$predictor
predictor[predictor=="depth_roots"] <- '#1f78b4'
predictor[predictor=="bio12"] <- '#a6cee3'
predictor[predictor=="bio2"] <- '#6a3d9a'
predictor[predictor=="bio14"] <- '#e31a1c'
predictor[predictor=="bio1"] <- '#33a02c'
predictor[predictor=="water_top"] <- '#ffff33'
predictor[predictor=="TRI"] <- '#fb9a99'
#predictor[predictor==""] <- '#b2df8a'

# color by predictor:
col.pred <- rownames(correctiongp.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- predictor[i]
}

col.pred[grep("SNP",col.pred)] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99')
```

```{r PlotSNPsRDAcorrectionGPs, fig.height=8,fig.width=8}
# axes 1 & 2
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("topleft", legend=select.env, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)

# axes 1 & 3
plot(correctiongp.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-1,1), choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(correctiongp.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(correctiongp.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("bottomright", legend=select.env, bty="n", col="gray32", pch=21, cex=1, pt.bg=bg,ncol=2)
```

